<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Table from CSV</title>

    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/colreorder/1.6.2/css/colReorder.dataTables.min.css">

    <style>

        /* =========================================================
           THEME VARIABLES
           ========================================================= */
        :root {
            --bg-main: #121212;
            --bg-panel: #1e1e1e;
            --bg-elevated: #252525;
            --bg-hover: #2f2f2f;

            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;

            --border-subtle: #333;
            --border-strong: #444;

            --accent: #4dabf7;
            --accent-hover: #339af0;

            --danger: #ff6b6b;
        }

        body.light-theme {
            --bg-main: #f8f9fa;
            --bg-panel: #ffffff;
            --bg-elevated: #f1f3f5;
            --bg-hover: #e9ecef;

            --text-main: #212529;
            --text-muted: #6c757d;

            --border-subtle: #ced4da;
            --border-strong: #adb5bd;

            --accent: #007bff;
            --accent-hover: #0056b3;
        }

        /* =========================================================
           BASE LAYOUT
           ========================================================= */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-main);
            color: var(--text-main);
        }

        table {
            width: 100%;
            background: var(--bg-panel);
            color: var(--text-main);
        }

        /* =========================================================
           CONTROLS / TOOLBAR
           ========================================================= */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: var(--bg-panel);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Top bar: Title and Main Actions */
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls-title {
            margin: 0;
            font-size: 22px;
            letter-spacing: -0.5px;
        }

        .controls-main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: stretch;
            transition:
                max-height 0.22s ease,
                opacity 0.18s ease,
                transform 0.18s ease;
            overflow: hidden;
        }

        /* Collapsed state (after CSV load) */
        .controls-main-grid.is-collapsed {
            max-height: 0;
            opacity: 0;
            transform: translateY(-4px);
            pointer-events: none;
        }

        /* Expanded state (hover or pinned) */
        .controls-main-grid.is-expanded {
            max-height: 800px; /* comfortably larger than content */
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Pin button active state remains same */
        #controlsPinButton.is-active {
            background: var(--accent);
            color: var(--bg-main);
        }

        @media (max-width: 768px) {
            .controls-main-grid { grid-template-columns: 1fr; }
        }

        /* Info Cards */
        .status-card {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .controls-value {
            text-align: right;
            max-width: 70%; 
            color: var(--accent);
            font-weight: bold;
            
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            
            display: inline-block;
            vertical-align: middle;
        }

        .controls-status-item {
            display: flex;
            justify-content: space-between;
            font-size: 15px;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 4px;
        }

        .controls-status-item:last-child { border: none; }

        /* =========================================================
           DROP ZONE
           ========================================================= */
        #csvDropZone {
            background: var(--bg-elevated);
            border: 2px dashed var(--border-strong);
            color: var(--text-muted);
            padding: 16px; 
            text-align: center;
            border-radius: 5px;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; 
            box-sizing: border-box; 
        }
        
        #csvDropZone.dragover {
            background-color: #162233;
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        #csvDropZone:hover {
            transform: scale(1.02);
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-hover);
        }

        /* =========================================================
           BUTTONS
           ========================================================= */
        .btn {
            background: var(--accent);
            color: var(--bg-main);
            padding: 6px 14px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-strong);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn:hover {
            background: var(--accent-hover);
        }

        /* Hide default file input */
        #csvFile {
            display: none;
        }

        #fileButton {
            margin-right: 0;
        }

        /* =========================================================
           TABLE FILTERS
           ========================================================= */
        .filters th {
            vertical-align: top;
            padding: 4px;
        }

        /* Checkbox filter */
        .filter-box {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            max-height: 180px;
            overflow-y: auto;
            padding: 4px;
            font-size: 12px;
        }

        .filter-box label {
            display: block;
            cursor: pointer;
            white-space: nowrap;
        }

        .filter-box input {
            margin-right: 4px;
        }

        /* Text filter */
        .filter-text {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            width: 100%;
            box-sizing: border-box;
            font-size: 12px;
            padding: 4px;
        }

        /* =========================================================
           SORTING BUTTONS (TABLE HEADERS)
           ========================================================= */
        th .sort-asc,
        th .sort-desc {
            font-size: 10px;
            padding: 2px 4px;
            margin-left: 4px;
            border-radius: 3px;
            background: var(--accent);
            color: var(--bg-main);
            cursor: pointer;
            height: auto;
            line-height: 1;
            min-width: 0;
            display: inline-block;
            transition: background 0.2s;
        }

        th .sort-asc:hover,
        th .sort-desc:hover {
            background: var(--accent-hover);
        }

        .highlight-cell {
            display: block;
            padding: 2px 4px;
            border-radius: 2px;
            text-align: center;
            font-weight: normal;
            transition: background-color 0.2s, font-weight 0.2s;
        }

        .highlight-cell.low { font-weight: normal; }
        .highlight-cell.medium { font-weight: 500; }
        .highlight-cell.high { font-weight: bold; }

        body.light-mode .highlight-cell { color: black; }
        body.dark-mode  .highlight-cell { color: white; }

        /* =========================================================
           PREFILTER OVERLAY
           ========================================================= */
        .prefilter-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;

            display: flex;
            flex-direction: column;

            padding: 24px;
            color: #eee;

            /* single vertical scrollbar for overlay */
            overflow-y: auto;
            overflow-x: hidden;
        }

        .prefilter-notice {
            background-color: #2b2b2b;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
        }

        .prefilter-notice ul {
            margin: 4px 0 0 16px;
            padding: 0;
        }

        .prefilter-notice strong {
            font-weight: bold;
        }

        .prefilter-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
            margin-top: 10px;

            /* grid itself does not scroll */
            overflow: visible;
        }

        /* PREFILTER ACTIONS */
        .prefilter-actions {
            width: 100%;
            display: flex;
            justify-content: center; /* center horizontally */
            position: sticky;
            bottom: 0; /* stick to bottom of viewport */
            background: rgba(44,44,44,0.95); /* semi-transparent for prominence */
            padding: 16px 0;
            z-index: 1100;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.5); /* subtle top shadow */
        }

        /* Submit button prominent styling */
        .prefilter-actions button {
            background: #f39c12; /* bright accent color */
            color: #111;
            font-weight: bold;
            font-size: 16px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .prefilter-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.3);
        }

        /* Cards with capped height */
        .filter-section {
            background: #1c1c1c;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;

            display: flex;
            flex-direction: column;

            /* max height for long cards */
            max-height: 180px;
            overflow: hidden;
        }

        .filter-section h3 {
            margin: 0 0 6px;
            font-size: 14px;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Values scroll only when needed */
        .filter-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 6px;
            overflow-y: auto;

            /* critical for flex/grid shrink behavior */
            min-height: 0;
            min-width: 0;
        }

        /* Checkbox layout with text wrapping */
        .filter-checkbox {
            font-size: 12px;
            display: flex;
            gap: 6px;
            align-items: flex-start; /* allow multi-line labels */
            min-height: 20px;
            line-height: 1.2;

            /* text wrapping */
            min-width: 0;
            white-space: normal;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        /* Prevent checkbox shrinking */
        .filter-checkbox input {
            flex-shrink: 0;
            margin-top: 2px;
        }

        /* Text input filters behave normally */
        .filter-section input[type="text"] {
            width: 100%;
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: #eee;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* =========================================================
           LOADING OVERLAY & PROGRESS
           ========================================================= */
        #loadingOverlayElement {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 999;
            background: rgba(0,0,0,0.85);
            color: var(--accent);
            font-size: 18px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin-top: 10px;
            border-radius: 50%;
            border: 6px solid #eee;
            border-top: 6px solid var(--accent);
            animation: spin 0.5s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to   { transform: rotate(360deg); }
        }

        #loadingHeaderDisplay {
            font-size: 22px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 16px;
            text-align: center;
        }

        /* Progress bar */
        #loadingProgressDisplayContainer {
            width: 80%;
            margin-top: 15px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #loadingProgressBarDisplay {
            width: 0%;
            height: 20px;
            background: var(--accent);
            transition: width 0.1s;
        }

        #loadingProgressTextDisplay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }

        #stopLoadingButton {
            margin-top: 20px;
            padding: 10px 24px;
            font-size: 16px;
            font-weight: bold;
            background-color: var(--danger);
            color: var(--bg-main);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #stopLoadingButton:hover {
            background-color: #ff4c4c; /* slightly brighter red on hover */
        }

        /* =========================================================
           IMAGE MODAL
           ========================================================= */
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.95);
            color: white;
            flex-direction: column;
        }

        #imageModalHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #111;
        }

        #imageModalGrid {
            flex-grow: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            overflow-y: auto;
        }

        #imageModalGrid img {
            width: 100%;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Fullscreen image preview */
        #imageOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.9);
            align-items: center;
            justify-content: center;
        }

        #imageOverlay img {
            max-width: 90%;
            max-height: 90%;
        }
    </style>

</head>
<body>


<div class="controls">
    <div class="controls-header">
        <h2 class="controls-title">Game Data Viewer</h2>
        <div class="btn-group">
            <button id="themeToggleButton" class="btn btn-secondary" title="Toggle between light and dark theme">üåô Dark</button>
            <button id="resetFiltersButton" class="btn btn-secondary" title="Reset all filters and sorting to their default state">üîÑ Reset Filters</button>
            <button id="searchButton" class="btn" title="Search the data">üîÑ Search</button>
        </div>
    </div>



</div>


<table id="csvTable" class="display"></table>

<div id="loadingOverlayElement">
    <div id="loadingHeaderDisplay">Loading Data...</div>
    <div class="spinner"></div>
    <div id="loadingProgressDisplayContainer">
        <div id="loadingProgressBarDisplay"></div>
        <span id="loadingProgressTextDisplay">0%</span>
    </div>
    <button id="stopLoadingButton">‚èπ Stop</button>
</div>
</div>




<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/colreorder/1.6.2/js/dataTables.colReorder.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>





<script>


const csvTableElement = $('#csvTable');
const themeToggleButton = document.getElementById('themeToggleButton');
const resetFiltersButton = document.getElementById('resetFiltersButton')
const searchButton = document.getElementById('searchButton')
const stopLoadingButton = document.getElementById('stopLoadingButton')
const loadingOverlayElement = document.getElementById('loadingOverlayElement');
const loadingHeader = document.getElementById('loadingHeaderDisplay');
const loadingProgressBar = document.getElementById('loadingProgressBarDisplay');
const loadingProgressText = document.getElementById('loadingProgressTextDisplay');

let activeCsvFile = null;
let activePrefilters = {};
let loadingCancelled = false;

async function yieldToBrowser() {
    await new Promise(r => setTimeout(r, 0)); // OLD
    // if (!document.hidden) await new Promise(r => setTimeout(r, 0));
}

function showLoading() { loadingOverlayElement.style.display = 'flex'; }

function hideLoading() { loadingOverlayElement.style.display = 'none'; }

function resetLoadingCancellation() {loadingCancelled = false;}

function cancelLoading() {loadingCancelled = true;}

async function updateLoadingProgress(header, startPercent, endPercent, currentStep, totalSteps) {
    if (totalSteps <= 0) totalSteps = 1;

    const fractionOfPhase = currentStep / totalSteps;
    const totalPercent = startPercent + fractionOfPhase * (endPercent - startPercent);

    loadingHeader.textContent = header
    loadingProgressBar.style.width = totalPercent + '%';
    loadingProgressText.textContent = totalPercent.toFixed(2) + '%';

    //console.log(`Progress: ${totalPercent.toFixed(2)}% | Step: ${currentStep}/${totalSteps} | Phase: ${startPercent} ‚Üí ${endPercent}%`); // debug

    await yieldToBrowser();
}

async function setActiveCsvFile(file) {
    activeCsvFile = file;
}

function updatePrefilters(prefilters, fileName) {
    activePrefilters = prefilters;
}

async function loadDefaultCsv() {
    if(activeCsvFile){
        return; // already loaded
    }
    const response = await fetch('data/game_data.csv');
    if (!response.ok) {
        alert('Failed to load default CSV');
        return;
    }

    const blob = await response.blob();
    const file = new File([blob], 'game_data.csv', { type: 'text/csv' });

    setActiveCsvFile(file);
}

async function loadDefaultPrefiltersJson() {
    if(activePrefilters && Object.keys(activePrefilters).length > 0){
        return; // already loaded
    }
    const response = await fetch('data/game_prefilters.json');
    if (!response.ok) {
        alert('Failed to load default prefilters');
        return;
    }
    const prefilters = await response.json();
    updatePrefilters(prefilters, 'game_prefilters.json');
}

async function executeCsvSearchWithRetries() {
    while (true) {
        try {
            const success = await executeCsvSearch(activeCsvFile);
            if (success) return true; // search finished successfully

        } catch (err) {
            console.error('CSV search failed:', err);
            alert(`Error: ${err.message || 'Unknown error'}\nFailed to search CSV: ${activeCsvFile?.name || 'unknown file'}`);
            break; // stop the loop on exception
        }

        // Optional small delay (if loop continues in future)
        await new Promise(r => setTimeout(r, 100));
    }
}

async function executeCsvSearch(file) {
    if (!file) return false;

    try {
        const collectedPrefilters =
            activePrefilters && Object.keys(activePrefilters).length > 0
                ? await showPrefilterOverlayAndCollectFilters(activePrefilters)
                : {};

        await updateLoadingProgress("Starting Data Search...", 0, 0, 0, 1);
        resetLoadingCancellation();
        showLoading();

        await loadCsvAndBuildTable({ file, totalSize: file.size, preFilters: collectedPrefilters });

        return true;
    } catch (err) {
        console.error('executeCsvSearch failed:', err);
        alert(`Error: ${err.message || 'Unknown error'}\nFailed to search CSV`);
        return false;
    } finally {
        hideLoading();
        resetLoadingCancellation();
        await updateLoadingProgress("", 0, 0, 0, 1);
    }
}

async function loadCsvAndBuildTable({ file, totalSize, preFilters }) {
    const parsedData = await parseAndFilterCsv(file, totalSize, preFilters);

    if (!Array.isArray(parsedData) || parsedData.length === 0) {
        throw new Error('No rows loaded');
    }

    const columns = createTableColumns(parsedData);
    await renderCsvTable(parsedData, columns);
}


async function parseAndFilterCsv(file, totalSize, preFilters) {
    const parsedData = [];
    let rowsProcessed = 0;
    let bytesProcessed = 0;
    const THROTTLE = 100;
    const MAX_ROWS = 10000; // maximum rows to prevent memory overload

    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            worker: true,
            step: function (row) {
                if (loadingCancelled) {
                    this.abort(); // stops PapaParse
                    reject(new Error('Loading cancelled by user.'));
                    return;
                }
                
                // Add row if passes preFilters
                if (!preFilters || Object.keys(preFilters).length === 0 || isRowAllowedByPrefilter(row.data, preFilters)) {
                    parsedData.push(row.data);
                }

                rowsProcessed++;
                bytesProcessed += new TextEncoder().encode(Object.values(row.data).join(',') + '\n').length;

                // Throttle progress updates
                if (rowsProcessed % THROTTLE === 0) {
                    updateLoadingProgress("Loading Data From File...", 0, 30, bytesProcessed, totalSize);
                }

                // Stop if max rows exceeded
                if (parsedData.length >= MAX_ROWS) {
                    // Reject the promise instead of throwing
                    reject(new Error(
                        `Too many items loaded (${MAX_ROWS}). Please use filters to reduce the number of items before loading.`
                    ));
                }
            },
            complete: function () {
                updateLoadingProgress("Loading Data From File Finished...", 0, 30, totalSize, totalSize);
                resolve(parsedData);
            },
            error: function (err) {
                reject(err); // Ensure rejection on any parsing error
            }
        });
    });
}

function isRowAllowedByPrefilter(row, preFilter) {
    return Object.entries(preFilter).every(([col, allowedValues]) => {
        const rawVal = row[col];
        const val = rawVal != null ? String(rawVal).trim() : '';

        // Empty or invalid allowedValues or empty string ‚Üí allow all
        if (!Array.isArray(allowedValues) || allowedValues.length === 0 || val === "") {
            return true;
        }

        // Check if value is allowed
        return allowedValues.includes(val);
    });
}

function createTableColumns(parsedData) {
    if (!parsedData || !parsedData.length) return [];

    const keys = Object.keys(parsedData[0]);
    const columns = keys.map(key => ({
        title: key,
        data: key,
        render: (data, type, row, meta) => renderCellValue(data, key)
    }));

    // Add the "View Images" column if "location" exists
    if (keys.includes('location')) {
        columns.unshift({
            title: 'View Images',
            data: '__view_images__', // reserved key
            orderable: false,
            searchable: false,
            render: (data, type, row, meta) => {
                return `<button class="btn view-images">View</button>`;
            }
        });
    }

    return columns;
}

async function renderCsvTable(data, columns) {
    showLoading();
    
    csvTableElement.hide();
    
    destroyExistingTable();
    createTableHeader(columns);
    const tbody = createTableBody();
    await appendRowsToTableInChunks(data, columns, tbody);
    await initializeDataTableWithOptions(columns);
    
    csvTableElement.show();
    await updateLoadingProgress("Csv Table Render Complete.", 100, 100, 1, 1);
    hideLoading();
}

function destroyExistingTable() {
    try {
        if ($.fn.DataTable.isDataTable(csvTableElement)) {
            csvTableElement.DataTable().destroy();
        }
    } catch (e) {
        console.warn('Failed to destroy existing DataTable:', e);
    } finally {
        csvTableElement.empty(); // clear old header/body safely
    }
}

function createTableHeader(columns) {
    const thead = $('<thead>');
    const headerRow = $('<tr>');
    const filterRow = $('<tr class="filters">');

    columns.forEach(col => {
        headerRow.append(`<th>${col.title}</th>`);
        filterRow.append('<th></th>');
    });

    thead.append(headerRow).append(filterRow);
    csvTableElement.append(thead);
}

function createTableBody() {
    const tbody = $('<tbody>');
    csvTableElement.append(tbody);
    return tbody;
}

async function appendRowsToTableInChunks(data, columns, tbody) {
    const CHUNK_SIZE = 500;

    for (let start = 0; start < data.length; start += CHUNK_SIZE) {
        if (loadingCancelled) throw new Error('Loading cancelled by user.');
        
        const chunk = data.slice(start, start + CHUNK_SIZE);
        const fragment = document.createDocumentFragment();

        chunk.forEach(rowData => {
            const tr = document.createElement('tr');

            // Render cells based on column definitions
            columns.forEach(col => {
                const td = document.createElement('td');

                if (col.data === '__view_images__') {
                    td.innerHTML = `<button class="btn view-images">View</button>`;
                } else {
                    td.innerHTML = renderCellValue(rowData[col.data], col.data);
                }

                tr.appendChild(td);
            });

            fragment.appendChild(tr);
        });

        tbody[0].appendChild(fragment);

        await updateLoadingProgress("Filling Rows In Table...", 30, 70, Math.min(start + CHUNK_SIZE, data.length), data.length);
        await yieldToBrowser();
    }
}

function initializeDataTableWithOptions(columns) {
    return new Promise(resolve => {

        const dt = csvTableElement.DataTable({
            paging: true,
            pageLength: 100,
            lengthMenu: [
                [50, 100, 200, 500, 1000],
                [50, 100, 200, 500, 1000]
            ],
            fixedHeader: true,
            colReorder: true,
            autoWidth: false,
            orderCellsTop: true,

            dom: '<"top"lfip>rt<"bottom"lfip><"clear">',

            initComplete: async function () {
                const api = this.api();

                await addColumnFilters(api);
                await addSortingControls(api, dt);

                resolve(); // EVERYTHING IS REALLY DONE NOW
            }
        });
    });
}


async function addColumnFilters(api) {
    const colCount = api.columns().count();

    for (let colIdx = 0; colIdx < colCount; colIdx++) {
        if (loadingCancelled) throw new Error('Loading cancelled by user.');
        
        const column = api.column(colIdx);
        const cell = $('.filters th').eq(colIdx);

        // Collect unique values
        const values = new Set();
        column.data().each(val => {
            const clean = $('<div>').html(val).text().trim();
            values.add(clean || '(Blanks)');
        });

        const sorted = Array.from(values).sort();

        if (sorted.length <= 20) {
            const box = $('<div class="filter-box"></div>').appendTo(cell);

            // Add "Select All / Uncheck All" checkbox at the top
            const selectAll = $(`<label><input type="checkbox" class="select-all" checked> Toggle All</label>`);
            box.append(selectAll);

            sorted.forEach(v => {
                box.append(`
                    <label>
                        <input type="checkbox" value="${v}" checked>
                        ${v}
                    </label>
                `);
            });

            // Event: toggle all checkboxes
            box.on('change', '.select-all', function () {
                const checked = $(this).is(':checked');
                box.find('input[type="checkbox"]').not(this).prop('checked', checked).trigger('change');
            });

            // Event: individual checkboxes
            box.on('change', 'input:not(.select-all)', function () {
                const checkedVals = box.find('input[type="checkbox"]:not(.select-all):checked')
                    .map((_, el) => $(el).val())
                    .get();

                // Update "Select All" checkbox based on individual checkboxes
                selectAll.find('input').prop('checked', checkedVals.length === sorted.length);

                // Apply filtering
                if (checkedVals.length === 0 || checkedVals.length === sorted.length) {
                    column.search('').draw(); // show all if nothing or all selected
                    return;
                }

                const regex = '^(' + checkedVals.map(v =>
                    v === '(Blanks)' ? '' : $.fn.dataTable.util.escapeRegex(v)
                ).join('|') + ')$';

                column.search(regex, true, false).draw();
            });
        } else {
            $('<input type="text" class="filter-text" placeholder="Filter..." />')
                .appendTo(cell)
                .on('keyup change clear', function () {
                    column.search(this.value).draw();
                });
        }

        await updateLoadingProgress("Adding Column Filters...", 70, 99, colIdx + 1, colCount);
        await yieldToBrowser();
    }
}

async function addSortingControls(api, dt) {
    const totalSortingSteps = csvTableElement.find('thead tr:first-child th').length;

    csvTableElement.find('thead tr:first-child th').each(async function (index) {
        const th = $(this);

        // Only add buttons once
        if (!th.find('.sort-asc').length) {
            const title = th.text().trim();
            th.html(`
                ${title}
                <button class="sort-asc btn" data-col="${index}">‚Üë</button>
                <button class="sort-desc btn" data-col="${index}">‚Üì</button>
            `);
        }
    });

    // Attach click handlers (if not already attached)
    if (!csvTableElement.data('sortingButtonsBound')) {
        csvTableElement.on('click', '.sort-asc', function () {
            dt.order([$(this).data('col'), 'asc']).draw();
        });

        csvTableElement.on('click', '.sort-desc', function () {
            dt.order([$(this).data('col'), 'desc']).draw();
        });

        csvTableElement.data('sortingButtonsBound', true);
    }
}

const HIGHLIGHT_COLUMNS = {
    user_rating: { min: 0, max: 100 },
    bayesian_rating: { min: 2, max: 5 },
    site_rating: { min: 1, max: 5 }
};

function renderCellValue(val, colName = null) {
    if (typeof val !== 'string') return val;

    const text = val.trim();

    const toFileUrl = path => {
        if (path.startsWith('http')) return path;
        let urlPath = path.replace(/\\/g, '/');
        if (!urlPath.startsWith('/')) urlPath = '/' + urlPath;
        return 'file:///' + urlPath;
    };

    // Excel-style HYPERLINK formula
    const hyperlinkMatch = text.match(/^=HYPERLINK\("([^"]+)",\s*"([^"]+)"\)$/i);
    if (hyperlinkMatch) {
        const [, rawPath, label] = hyperlinkMatch;
        return `<a href="${toFileUrl(rawPath)}" target="_blank">${label}</a>`;
    }

    // Web URLs
    if (/^https?:\/\//i.test(text)) return `<a href="${text}" target="_blank">${text}</a>`;

    // Local Windows path
    if (/^[a-zA-Z]:\\/.test(text)) return `<a href="${toFileUrl(text)}" target="_blank">${text}</a>`;

    // Column-specific highlighting
    if (colName && HIGHLIGHT_COLUMNS[colName]) {
        const { min, max } = HIGHLIGHT_COLUMNS[colName];
        return highlightValue(text, min, max);
    }

    return text;
}

function highlightValue(val, min, max) {
    const num = parseFloat(val);
    if (isNaN(num)) return val;

    // Compute intensity 0 ‚Üí 1
    const intensity = Math.max(0, Math.min(1, (num - min) / (max - min)));

    const isLightMode = document.body.classList.contains('light-theme');

    // --- Four fixed extremes ---
    let low, high;
    if (isLightMode) {
        // Light mode: black text, red ‚Üí green
        low  = { h: 0,   s: 70, l: 80 };  // light red
        high = { h: 120, s: 70, l: 80 };  // light green (readable on black)
    } else {
        // Dark mode: white text, red ‚Üí green
        low  = { h: 0,   s: 70, l: 20 };  // dark red
        high = { h: 120, s: 70, l: 20 };  // dark green (readable on white)
    }

    // Interpolate HSL between low and high
    const hue = Math.round(low.h + (high.h - low.h) * intensity);
    const saturation = Math.round(low.s + (high.s - low.s) * intensity);
    const lightness = Math.round(low.l + (high.l - low.l) * intensity);
    const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    const textColor = isLightMode ? '#000000' : '#ffffff';
    const weightClass = intensity > 0.7 ? 'high' : intensity > 0.4 ? 'medium' : 'low';
    return `<span class="highlight-cell ${weightClass}" style="background-color:${bgColor}; color:${textColor}">${val}</span>`;
}

function normalizeFilters(filters) {
    const normalized = {};
    Object.entries(filters).forEach(([col, values]) => {
        normalized[col] = Array.isArray(values)
            ? values.map(v => String(v).trim()).filter(v => v !== '')
            : [];
    });
    return normalized;
}

async function showPrefilterOverlayAndCollectFilters(filters) {
    try {
        const normalized = normalizeFilters(filters);
        const overlay = createPrefilterOverlayContainer('Refine Your Search');

        // Add notice
        overlay.appendChild(createPrefilterNotice());

        // Form wrapper
        const form = document.createElement('form');

        // Add actions and grid
        form.appendChild(createPrefilterActions());
        form.appendChild(createPrefilterGrid(normalized));

        overlay.appendChild(form);
        document.body.appendChild(overlay);

        // Wait for submission
        return new Promise(resolve =>
            waitForPrefilterFormSubmission(form, resolve, overlay)
        );
    } catch (err) {
        console.warn('Prefilter UI failed, continuing without prefiltering:', err);
        return {};
    }
}

// Main function to create the overlay container
function createPrefilterOverlayContainer(title) {
    const overlay = document.createElement('div');
    overlay.id = 'prefilterOverlay';
    overlay.className = 'prefilter-overlay'; // move all styling to CSS
    overlay.innerHTML = `<h2>${title}</h2>`;
    return overlay;
}

// ‚ö† Important notice
function createPrefilterNotice() {
    const notice = document.createElement('div');
    notice.className = 'prefilter-notice';
    notice.innerHTML = `
        ‚ö† <strong>Important: Use Prefilters to Reduce Load</strong><br>
        The tool loads the entire dataset captured from the site, which can be very large. 
        Unless you use prefilters to narrow it down, your browser may take a long time to load the data, 
        and it can become very memory-intensive.<br><br>
        All processing happens client-side ‚Äî this is just a static webpage running in your browser. 
        You‚Äôll see a ‚ÄúLoading Data‚Ä¶‚Äù overlay while it loads.<br><br>
        <strong>To improve performance:</strong>
        <ul>
            <li>Use the prefilters to limit the number of rows loaded.</li>
            <li>Start with broad filters and refine them gradually if needed.</li>
            <li>If loading becomes too slow, stop the processing, refresh the page and adjust your prefilters.</li>
        </ul>
        Proper use of prefilters ensures a faster, smoother experience when exploring the table.
    `;
    return notice;
}

// Action buttons container
function createPrefilterActions() {
    const actions = document.createElement('div');
    actions.className = 'prefilter-actions sticky-top';
    actions.appendChild(createPrefilterSubmitButton('Apply Filters & Search'));
    return actions;
}

// Grid containing all filters
function createPrefilterGrid(normalizedFilters) {
    const grid = document.createElement('div');
    grid.className = 'prefilter-form'; // CSS handles layout
    for (const [col, values] of Object.entries(normalizedFilters)) {
        grid.appendChild(createFilterSectionForColumn(col, values));
    }
    return grid;
}

function createFilterSectionForColumn(col, values) {
    const section = document.createElement('section');
    section.className = 'filter-section';

    const title = document.createElement('h3');
    title.textContent = col;
    section.appendChild(title);

    if (!values.length || values.length > 30) {
        section.appendChild(createTextFilterInput(col));
    } else {
        const list = document.createElement('div');
        list.className = 'filter-values';

        values.forEach(v => list.appendChild(createPrefilterCheckbox(col, v)));
        section.appendChild(list);
    }

    return section;
}

function createTextFilterInput(name) {
    const input = document.createElement('input');
    input.type = 'text';
    input.name = name;
    input.placeholder = `Filter ${name}‚Ä¶`;
    return input;
}

function createPrefilterCheckbox(name, value) {
    const label = document.createElement('label');
    label.className = 'filter-checkbox';

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.name = name;
    input.value = value;
    input.checked = true;

    label.append(input, document.createTextNode(value));
    return label;
}

function createPrefilterSubmitButton(label = 'Submit') {
    const btn = document.createElement('button');
    btn.type = 'submit';
    btn.textContent = label;
    btn.className = 'btn';
    btn.style.marginTop = '10px';
    return btn;
}

function waitForPrefilterFormSubmission(form, resolve, overlay) {
    form.addEventListener('submit', e => {
        e.preventDefault();
        const preFilter = {};

        // Collect values from form inputs
        new FormData(form).forEach((value, key) => {
            value = String(value).trim();
            if (!value) return; // skip empty inputs

            if (!preFilter[key]) preFilter[key] = [];
            preFilter[key].push(value);
        });

        overlay.remove();
        resolve(preFilter);
    });
}

function loadAndUpdateTheme() {
    // Load saved theme
    if (localStorage.getItem('theme') === 'light') {
        document.body.classList.add('light-theme');
    }
    updateThemeButton()
}

function updateThemeButton() {
    const isLight = document.body.classList.contains('light-theme');
    themeToggleButton.textContent = isLight ? 'üåû Light' : 'üåô Dark';
}


loadAndUpdateTheme();


// Search button
searchButton.addEventListener('click', async () => {
    if (!activeCsvFile) return alert('No CSV file loaded yet.');
    if (!activePrefilters || Object.keys(activePrefilters).length === 0) return alert('No prefilters json loaded yet.');
    await executeCsvSearchWithRetries();
});

// Reset filters button
resetFiltersButton.addEventListener('click', () => {
    if (!$.fn.DataTable.isDataTable(csvTableElement)) return;

    const dt = csvTableElement.DataTable();

    // Reset column searches
    dt.columns().every(function() {
        this.search('');
    });

    // Reset checkboxes
    $('.filter-box input[type="checkbox"]').prop('checked', true);

    // Reset text inputs
    $('.filter-text').val('');

    // Reset column order
    if (dt.colReorder) dt.colReorder.reset();

    // Reset sorting
    dt.order([]).draw(); // only one redraw here
});

// Theme toggle button
themeToggleButton.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    updateThemeButton();
});

// Stop loading button
stopLoadingButton.addEventListener('click', () => {
    cancelLoading();
    hideLoading();
});


</script>








<!-- Code injected for standalone web deployment -->
<script>
(async () => {
    await loadDefaultCsv();
    await loadDefaultPrefiltersJson();
    await executeCsvSearchWithRetries();
})();
</script>



<!--
<script>
(async () => {
    await loadDefaultCsv();
    await loadDefaultPrefiltersJson();
    await executeCsvSearchWithRetries();
})();
</script>
-->


</body>
</html>
