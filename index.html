<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Table from CSV</title>

    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/colreorder/1.6.2/css/colReorder.dataTables.min.css">

    <style>

        /* =========================================================
           THEME VARIABLES
           ========================================================= */
        :root {
            --bg-main: #121212;
            --bg-panel: #1e1e1e;
            --bg-elevated: #252525;
            --bg-hover: #2f2f2f;

            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;

            --border-subtle: #333;
            --border-strong: #444;

            --accent: #4dabf7;
            --accent-hover: #339af0;

            --danger: #ff6b6b;
        }

        body.light-theme {
            --bg-main: #f8f9fa;
            --bg-panel: #ffffff;
            --bg-elevated: #f1f3f5;
            --bg-hover: #e9ecef;

            --text-main: #212529;
            --text-muted: #6c757d;

            --border-subtle: #ced4da;
            --border-strong: #adb5bd;

            --accent: #007bff;
            --accent-hover: #0056b3;
        }

        /* =========================================================
           BASE LAYOUT
           ========================================================= */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-main);
            color: var(--text-main);
        }

        table {
            width: 100%;
            background: var(--bg-panel);
            color: var(--text-main);
        }

        /* =========================================================
           CONTROLS / TOOLBAR
           ========================================================= */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: var(--bg-panel);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Top bar: Title and Main Actions */
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls-title {
            margin: 0;
            font-size: 22px;
            letter-spacing: -0.5px;
        }

        .controls-main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: stretch;
            transition:
                max-height 0.22s ease,
                opacity 0.18s ease,
                transform 0.18s ease;
            overflow: hidden;
        }

        /* Collapsed state (after CSV load) */
        .controls-main-grid.is-collapsed {
            max-height: 0;
            opacity: 0;
            transform: translateY(-4px);
            pointer-events: none;
        }

        /* Expanded state (hover or pinned) */
        .controls-main-grid.is-expanded {
            max-height: 800px; /* comfortably larger than content */
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Pin button active state remains same */
        #controlsPinButton.is-active {
            background: var(--accent);
            color: var(--bg-main);
        }

        @media (max-width: 768px) {
            .controls-main-grid { grid-template-columns: 1fr; }
        }

        /* Info Cards */
        .status-card {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .controls-value {
            text-align: right;
            max-width: 70%; 
            color: var(--accent);
            font-weight: bold;
            
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            
            display: inline-block;
            vertical-align: middle;
        }

        .controls-status-item {
            display: flex;
            justify-content: space-between;
            font-size: 15px;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 4px;
        }

        .controls-status-item:last-child { border: none; }

        /* =========================================================
           DROP ZONE
           ========================================================= */
        #csvDropZone {
            background: var(--bg-elevated);
            border: 2px dashed var(--border-strong);
            color: var(--text-muted);
            padding: 16px; 
            text-align: center;
            border-radius: 5px;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; 
            box-sizing: border-box; 
        }
        
        #csvDropZone.dragover {
            background-color: #162233;
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        #csvDropZone:hover {
            transform: scale(1.02);
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-hover);
        }

        /* =========================================================
           BUTTONS
           ========================================================= */
        .btn {
            background: var(--accent);
            color: var(--bg-main);
            padding: 6px 14px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-strong);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn:hover {
            background: var(--accent-hover);
        }

        /* Hide default file input */
        #csvFile {
            display: none;
        }

        #fileButton {
            margin-right: 0;
        }

        /* =========================================================
           TABLE FILTERS
           ========================================================= */

        .filters th {
            padding: 4px;
            vertical-align: top;
        }

        .filters .filter-container {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transform: translateY(-6px);
            transition:
                max-height 0.22s ease,
                opacity 0.18s ease,
                transform 0.18s ease;
        }

        .filters.is-expanded .filter-container {
            max-height: 160px;
            opacity: 1;
            transform: translateY(0);
        }

        .filters.is-collapsed .filter-container {
            pointer-events: none;
        }

        /* ------------------- Checkbox Filter ------------------- */
        .filter-box {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            max-height: 180px;
            overflow-y: auto;
            padding: 4px;
            font-size: 12px;
        }

        .filter-box label {
            display: block;
            cursor: pointer;
            white-space: nowrap;
        }

        .filter-box input {
            margin-right: 4px;
        }

        .toggle-all-label {
            font-weight: bold;
            margin-bottom: 4px;
            display: block;
        }

        /* ------------------- Text Filter ------------------- */
        .filter-text {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            width: 100%;
            box-sizing: border-box;
            font-size: 12px;
            padding: 4px;
        }

        /* ------------------- Range Filter ------------------- */
        .filter-range {
            display: flex;
            flex-wrap: wrap;  /* allow min/max to wrap to next line */
            gap: 8px;
            align-items: flex-start; /* align top when wrapped */
        }

        /* wrapper for individual input + label */
        .range-input-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1 1 80px;  /* flexible width, min 80px */
            min-width: 80px; /* avoid inputs getting too small */
            width: 100%;  /* always fill wrapper */
            box-sizing: border-box;
        }

        /* label above the input */
        .range-label {
            font-size: 10px;
            color: var(--text-subtle);
            margin-bottom: 2px;
        }

        /* input styling consistent with other filters */
        .range-min,
        .range-max {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            padding: 2px 4px;
            font-size: 12px;
            width: 100%;
            box-sizing: border-box;
            border-radius: 3px;
        }

        /* =========================================================
           SORTING BUTTONS (TABLE HEADERS)
           ========================================================= */
        th .sort-asc,
        th .sort-desc {
            font-size: 10px;
            padding: 2px 4px;
            margin-left: 4px;
            border-radius: 3px;
            background: var(--accent);
            color: var(--bg-main);
            cursor: pointer;
            height: auto;
            line-height: 1;
            min-width: 0;
            display: inline-block;
            transition: background 0.2s;
        }

        th .sort-asc:hover,
        th .sort-desc:hover {
            background: var(--accent-hover);
        }

        .highlight-cell {
            display: block;
            padding: 2px 4px;
            border-radius: 2px;
            text-align: center;
            font-weight: normal;
            transition: background-color 0.2s, font-weight 0.2s;
        }

        .highlight-cell.low { font-weight: normal; }
        .highlight-cell.medium { font-weight: 500; }
        .highlight-cell.high { font-weight: bold; }

        body.light-mode .highlight-cell { color: black; }
        body.dark-mode  .highlight-cell { color: white; }

        /* =========================================================
           PREFILTER OVERLAY
           ========================================================= */
        .prefilter-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1000;

            display: flex;
            flex-direction: column;

            padding: 24px;
            color: #eee;

            /* single vertical scrollbar for overlay */
            overflow-y: auto;
            overflow-x: hidden;
        }

        .prefilter-notice {
            background-color: #2b2b2b;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
        }

        .prefilter-notice ul {
            margin: 4px 0 0 16px;
            padding: 0;
        }

        .prefilter-notice strong {
            font-weight: bold;
        }

        .prefilter-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
            margin-top: 10px;

            /* grid itself does not scroll */
            overflow: visible;
        }

        /* PREFILTER ACTIONS */
        .prefilter-actions {
            width: 100%;
            display: flex;
            justify-content: center; /* center horizontally */
            position: sticky;
            bottom: 0; /* stick to bottom of viewport */
            background: rgba(44,44,44,0.95); /* semi-transparent for prominence */
            padding: 16px 0;
            z-index: 1100;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.5); /* subtle top shadow */
        }

        /* Submit button prominent styling */
        .prefilter-actions button {
            background: #f39c12; /* bright accent color */
            color: #111;
            font-weight: bold;
            font-size: 16px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            margin-top: 10px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .prefilter-actions button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0,0,0,0.3);
        }

        /* Cards with capped height */
        .filter-section {
            background: #1c1c1c;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;

            display: flex;
            flex-direction: column;

            /* max height for long cards */
            max-height: 180px;
            overflow: hidden;
        }

        .filter-section h3 {
            margin: 0 0 6px;
            font-size: 14px;
            font-weight: 600;
            flex-shrink: 0;
        }

        /* Values scroll only when needed */
        .filter-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 6px;
            overflow-y: auto;

            /* critical for flex/grid shrink behavior */
            min-height: 0;
            min-width: 0;
        }

        /* Checkbox layout with text wrapping */
        .filter-checkbox {
            font-size: 12px;
            display: flex;
            gap: 6px;
            align-items: flex-start; /* allow multi-line labels */
            min-height: 20px;
            line-height: 1.2;

            /* text wrapping */
            min-width: 0;
            white-space: normal;
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        /* Prevent checkbox shrinking */
        .filter-checkbox input {
            flex-shrink: 0;
            margin-top: 2px;
        }

        /* Text input filters behave normally */
        .filter-section input[type="text"] {
            width: 100%;
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: #eee;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* =========================================================
           LOADING OVERLAY & PROGRESS
           ========================================================= */
        #loadingOverlayElement {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 999;
            background: rgba(0,0,0,0.85);
            color: var(--accent);
            font-size: 18px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin-top: 10px;
            border-radius: 50%;
            border: 6px solid #eee;
            border-top: 6px solid var(--accent);
            animation: spin 0.5s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to   { transform: rotate(360deg); }
        }

        #loadingHeaderDisplay {
            font-size: 22px;
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 16px;
            text-align: center;
        }

        /* Progress bar */
        #loadingProgressDisplayContainer {
            width: 80%;
            margin-top: 15px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #loadingProgressBarDisplay {
            width: 0%;
            height: 20px;
            background: var(--accent);
            transition: width 0.1s;
        }

        #loadingProgressTextDisplay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }

        #stopLoadingButton {
            margin-top: 20px;
            padding: 10px 24px;
            font-size: 16px;
            font-weight: bold;
            background-color: var(--danger);
            color: var(--bg-main);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #stopLoadingButton:hover {
            background-color: #ff4c4c; /* slightly brighter red on hover */
        }

        /* =========================================================
           IMAGE MODAL
           ========================================================= */
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.95);
            color: white;
            flex-direction: column;
        }

        #imageModalHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #111;
        }

        #imageModalGrid {
            flex-grow: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            overflow-y: auto;
        }

        #imageModalGrid img {
            width: 100%;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Fullscreen image preview */
        #imageOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.9);
            align-items: center;
            justify-content: center;
        }

        #imageOverlay img {
            max-width: 90%;
            max-height: 90%;
        }
    </style>

</head>
<body>


<div class="controls">
    <div class="controls-header">
        <h2 class="controls-title">Game Data Viewer</h2>
        <div class="btn-group">
            <button id="themeToggleButton" class="btn btn-secondary" title="Toggle between light and dark theme">üåô Dark</button>
            <button id="resetFiltersButton" class="btn btn-secondary" title="Reset all filters and sorting to their default state">üîÑ Reset Filters</button>
            <button id="searchButton" class="btn" title="Search the data">üîÑ Search</button>
        </div>
    </div>



</div>


<table id="csvTable" class="display"></table>

<div id="loadingOverlayElement">
    <div id="loadingHeaderDisplay">Loading Data...</div>
    <div class="spinner"></div>
    <div id="loadingProgressDisplayContainer">
        <div id="loadingProgressBarDisplay"></div>
        <span id="loadingProgressTextDisplay">0%</span>
    </div>
    <button id="stopLoadingButton">‚èπ Stop</button>
</div>
</div>




<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/colreorder/1.6.2/js/dataTables.colReorder.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>





<script>


const csvTableElement = $('#csvTable');
const themeToggleButton = document.getElementById('themeToggleButton');
const resetFiltersButton = document.getElementById('resetFiltersButton')
const searchButton = document.getElementById('searchButton')
const stopLoadingButton = document.getElementById('stopLoadingButton')
const loadingOverlayElement = document.getElementById('loadingOverlayElement');
const loadingHeader = document.getElementById('loadingHeaderDisplay');
const loadingProgressBar = document.getElementById('loadingProgressBarDisplay');
const loadingProgressText = document.getElementById('loadingProgressTextDisplay');

let activeCsvFile = null;
let activeColumnDetails = {};
let loadingCancelled = false;

async function yieldToBrowser() {
    await new Promise(r => setTimeout(r, 0)); // OLD
    // if (!document.hidden) await new Promise(r => setTimeout(r, 0));
}

function showLoading() { loadingOverlayElement.style.display = 'flex'; }

function hideLoading() { loadingOverlayElement.style.display = 'none'; }

function resetLoadingCancellation() {loadingCancelled = false;}

function cancelLoading() {loadingCancelled = true;}

async function updateLoadingProgress(header, startPercent, endPercent, currentStep, totalSteps) {
    if (totalSteps <= 0) totalSteps = 1;

    const fractionOfPhase = currentStep / totalSteps;
    const totalPercent = startPercent + fractionOfPhase * (endPercent - startPercent);

    loadingHeader.textContent = header
    loadingProgressBar.style.width = totalPercent + '%';
    loadingProgressText.textContent = totalPercent.toFixed(2) + '%';

    //console.log(`Progress: ${totalPercent.toFixed(2)}% | Step: ${currentStep}/${totalSteps} | Phase: ${startPercent} ‚Üí ${endPercent}%`); // debug

    await yieldToBrowser();
}

async function setActiveCsvFile(file) {
    activeCsvFile = file;
}

function updateColumnDetails(columnDetails, fileName, description) {
    activeColumnDetails = columnDetails;
}

async function loadDefaultCsv() {
    if(activeCsvFile){
        return; // already loaded
    }
    const response = await fetch('data/game_data.csv');
    if (!response.ok) {
        alert('Failed to load default CSV');
        return;
    }

    const blob = await response.blob();
    const file = new File([blob], 'game_data.csv', { type: 'text/csv' });

    setActiveCsvFile(file);
}

async function loadDefaultColumnDetailsJson() {
    if(activeColumnDetails && Object.keys(activeColumnDetails).length > 0){
        return; // already loaded
    }
    const response = await fetch('data/game_column_details.json');
    if (!response.ok) {
        alert('Failed to load default column details');
        return;
    }
    const columnDetails = await response.json();
    updateColumnDetails(columnDetails, 'game_column_details.json', 'Loaded from data/game_column_details.json');
}

async function executeCsvSearchWithRetries() {
    while (true) {
        try {
            const success = await executeCsvSearch(activeCsvFile);
            if (success) return true; // search finished successfully

        } catch (err) {
            console.error('CSV search failed:', err);
            alert(`Error: ${err.message || 'Unknown error'}\nFailed to search CSV: ${activeCsvFile?.name || 'unknown file'}`);
            break; // stop the loop on exception
        }

        // Optional small delay (if loop continues in future)
        await new Promise(r => setTimeout(r, 100));
    }
}

async function executeCsvSearch(file) {
    if (!file) return false;

    try {
        const collectedPrefilters =
            activeColumnDetails && Object.keys(activeColumnDetails).length > 0
                ? await showPrefilterOverlayAndCollectFilters(activeColumnDetails)
                : {};

        await updateLoadingProgress("Starting Data Search...", 0, 0, 0, 1);
        resetLoadingCancellation();
        showLoading();

        await loadCsvAndBuildTable({ file, totalSize: file.size, preFilters: collectedPrefilters });

        return true;
    } catch (err) {
        console.error('executeCsvSearch failed:', err);
        alert(`Error: ${err.message || 'Unknown error'}\nFailed to search CSV`);
        return false;
    } finally {
        hideLoading();
        resetLoadingCancellation();
        await updateLoadingProgress("", 0, 0, 0, 1);
    }
}

async function loadCsvAndBuildTable({ file, totalSize, preFilters }) {
    const parsedData = await parseAndFilterCsv(file, totalSize, preFilters);

    if (!Array.isArray(parsedData) || parsedData.length === 0) {
        throw new Error('No rows loaded');
    }

    determineColumnDetailsFromDataIfNeeded(parsedData)
    const columns = createTableColumns(parsedData);
    await renderCsvTable(parsedData, columns);
}

async function parseAndFilterCsv(file, totalSize, preFilters) {
    const parsedData = [];
    let rowsProcessed = 0;
    let bytesProcessed = 0;
    const THROTTLE = 100;
    const MAX_ROWS = 30000; // maximum rows to prevent memory overload

    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            worker: true,
            step: function (row) {
                if (loadingCancelled) {
                    this.abort(); // stops PapaParse
                    reject(new Error('Loading cancelled by user.'));
                    return;
                }
                
                // Add row if passes preFilters
                if (!preFilters || Object.keys(preFilters).length === 0 || isRowAllowedByPrefilter(row.data, preFilters)) {
                    parsedData.push(row.data);
                }

                rowsProcessed++;
                bytesProcessed += new TextEncoder().encode(Object.values(row.data).join(',') + '\n').length;

                // Throttle progress updates
                if (rowsProcessed % THROTTLE === 0) {
                    updateLoadingProgress("Loading Data From File...", 0, 30, bytesProcessed, totalSize);
                }

                // Stop if max rows exceeded
                if (parsedData.length >= MAX_ROWS) {
                    this.abort();
                    // Reject the promise instead of throwing
                    reject(new Error(
                        `Too many items loaded (${MAX_ROWS}). Please use filters to reduce the number of items before loading.`
                    ));
                }
            },
            complete: function () {
                updateLoadingProgress("Loading Data From File Finished...", 0, 30, totalSize, totalSize);
                resolve(parsedData);
            },
            error: function (err) {
                reject(err); // Ensure rejection on any parsing error
            }
        });
    });
}

function isRowAllowedByPrefilter(row, preFilter) {
    if (!preFilter || Object.keys(preFilter).length === 0) return true;

    const normalize = v => (v == null ? '' : typeof v === 'string' ? v.trim() : v);

    return Object.entries(preFilter).every(([col, criterion]) => {
        const colDef = activeColumnDetails[col];
        if (!colDef) return true;

        const rawVal = row[col];
        const val = normalize(rawVal);

        // Numeric
        if (colDef.type === 'int' || colDef.type === 'float') {
            const num = Number(val);
            if (Number.isNaN(num)) return true;
            if (criterion.min != null && num < criterion.min) return false;
            if (criterion.max != null && num > criterion.max) return false;
            if (Array.isArray(criterion.choices) && criterion.choices.length > 0) {
                if (!criterion.choices.includes(num)) return false;
            }
            return true;
        }

        // Tag (0/1)
        if (colDef.type === 'tag') {
            if (!Array.isArray(criterion.choices)) return true;
            return criterion.choices.includes(Number(val));
        }

        // Boolean
        if (colDef.type === 'bool') {
            if (!Array.isArray(criterion.choices)) return true;
            return criterion.choices.includes(Boolean(val));
        }

        // Any type with choices
        if (Array.isArray(colDef.choices) && colDef.choices.length > 0) {
            if (!Array.isArray(criterion.choices)) return true;
            if (criterion.choices.length === 0) return false;
            let typedVal = val;
            if (colDef.type === 'int') typedVal = parseInt(val, 10);
            if (colDef.type === 'float') typedVal = parseFloat(val);
            if (colDef.type === 'bool') typedVal = Boolean(val);
            if (!criterion.choices.includes(typedVal)) return false;
            return true;
        }

        // Text search
        if (criterion.text && Array.isArray(criterion.text)) {
            const lowerVal = String(val).toLowerCase();
            return criterion.text.some(t => lowerVal.includes(String(t).toLowerCase()));
        }

        return true;
    });
}

function createTableColumns(parsedData) {
    if (!parsedData || !parsedData.length) return [];

    const keys = Object.keys(parsedData[0]);

    // Build columns, but skip columns with type 'tag'
    const columns = keys
        .filter(key => {
            const colDef = activeColumnDetails[key];
            return !(colDef && colDef.type === 'tag');
        })
        .map(key => ({
            title: key,
            data: key,
            render: (data, type, row, meta) => renderCellValue(data, key)
        }));

    // Add the "View Images" column at the front if "location" exists
    if (keys.includes('location')) {
        columns.unshift({
            title: 'View Images',
            data: '__view_images__', // reserved key
            orderable: false,
            searchable: false,
            render: (data, type, row, meta) => {
                return `<button class="btn view-images">View</button>`;
            }
        });
    }

    return columns;
}

async function renderCsvTable(data, columns) {
    showLoading();
    
    csvTableElement.hide();
    destroyExistingTable();
    
    createTableHeader(columns);
    const tbody = createTableBody();
    await appendRowsToTableInChunks(data, columns, tbody);
    await initializeDataTableWithOptions(columns);
    
    csvTableElement.show();
    await updateLoadingProgress("Csv Table Render Complete.", 100, 100, 1, 1);
    hideLoading();
}

function determineColumnDetailsFromDataIfNeeded(parsedData) {
    if (activeColumnDetails && Object.keys(activeColumnDetails).length > 0) return;
    if (!parsedData || parsedData.length === 0) return;

    const columnDetails = {};

    const numericRegex = /^[+-]?(?:\d+|\d*\.\d+)(?:[eE][+-]?\d+)?$/;
    const looksNumericString = v => {
        if (v === null || v === undefined) return false;
        const s = String(v).trim();
        return s !== '' && numericRegex.test(s);
    };

    const keys = Object.keys(parsedData[0] || {});
    keys.forEach(col => {
        const rawValues = parsedData.map(r => r[col]);
        const values = rawValues
            .filter(v => v !== undefined && v !== null)
            .map(v => String(v).trim())
            .filter(v => v !== '');

        if (values.length === 0) {
            columnDetails[col] = { type: 'str', choices: [] };
            return;
        }

        /* ---------- NUMERIC ---------- */
        if (values.every(looksNumericString)) {
            const nums = values.map(Number);
            const uniqueNums = Array.from(new Set(nums));
            const allInts = nums.every(Number.isInteger);

            // TAG (binary)
            if (uniqueNums.every(v => v === 0 || v === 1)) {
                columnDetails[col] = {
                    type: 'tag',
                    choices: [0, 1],
                    min: 0,
                    max: 1
                };
                return;
            }

            // RANGE
            columnDetails[col] = {
                type: allInts ? 'int' : 'float',
                choices: [],
                min: Math.min(...nums),
                max: Math.max(...nums)
            };
            return;
        }

        /* ---------- BOOLEAN DETECTION ---------- */
        const lowerVals = values.map(v => v.toLowerCase());
        if (lowerVals.every(v => v === 'true' || v === 'false')) {
            columnDetails[col] = {
                type: 'bool',
                choices: [false, true]
            };
            return;
        }

        /* ---------- STRING ---------- */
        const uniqueStrings = Array.from(new Set(values));

        columnDetails[col] = {
            type: 'str',
            choices: uniqueStrings.length <= 20 ? uniqueStrings : []
        };
    });

    // Hardcoded bounds
    if (columnDetails["bayesian_rating"]) {
        columnDetails["bayesian_rating"].min = 0;
        columnDetails["bayesian_rating"].max = 5;
    }
    if (columnDetails["site_rating"]) {
        columnDetails["site_rating"].min = 0;
        columnDetails["site_rating"].max = 5;
    }

    updateColumnDetails(columnDetails, "", "Determined from loaded data.");
}



function destroyExistingTable() {
    try {
        if ($.fn.DataTable.isDataTable(csvTableElement)) {
            csvTableElement.DataTable().destroy();
        }
    } catch (e) {
        console.warn('Failed to destroy existing DataTable:', e);
    } finally {
        csvTableElement.empty(); // clear old header/body safely
    }
}

function createTableHeader(columns) {
    const thead = $('<thead>');
    const headerRow = $('<tr>');
    const filterRow = $('<tr class="filters">');

    columns.forEach(col => {
        headerRow.append(`<th>${col.title}</th>`);
        filterRow.append('<th></th>');
    });

    thead.append(headerRow).append(filterRow);
    csvTableElement.append(thead);
}

function createTableBody() {
    const tbody = $('<tbody>');
    csvTableElement.append(tbody);
    return tbody;
}

async function appendRowsToTableInChunks(data, columns, tbody) {
    const CHUNK_SIZE = 500;

    for (let start = 0; start < data.length; start += CHUNK_SIZE) {
        if (loadingCancelled) throw new Error('Loading cancelled by user.');
        
        const chunk = data.slice(start, start + CHUNK_SIZE);
        const fragment = document.createDocumentFragment();

        chunk.forEach(rowData => {
            const tr = document.createElement('tr');

            // Render cells based on column definitions
            columns.forEach(col => {
                const td = document.createElement('td');

                if (col.data === '__view_images__') {
                    td.innerHTML = `<button class="btn view-images">View</button>`;
                } else {
                    td.innerHTML = renderCellValue(rowData[col.data], col.data);
                }

                tr.appendChild(td);
            });

            fragment.appendChild(tr);
        });

        tbody[0].appendChild(fragment);

        await updateLoadingProgress("Adding Rows To The Table...", 30, 70, Math.min(start + CHUNK_SIZE, data.length), data.length);
        await yieldToBrowser();
    }
}

function initializeDataTableWithOptions(columns) {
    return new Promise(resolve => {

        const dt = csvTableElement.DataTable({
            paging: true,
            pageLength: 100,
            lengthMenu: [
                [50, 100, 200, 500, 1000],
                [50, 100, 200, 500, 1000]
            ],
            fixedHeader: true,
            colReorder: true,
            autoWidth: false,
            orderCellsTop: true,

            dom: '<"top"lfip>rt<"bottom"lfip><"clear">',

            initComplete: async function () {
                const api = this.api();

                await addColumnFilters(api);
                await addSortingControls(api, dt);

                resolve(); // EVERYTHING IS REALLY DONE NOW
            }
        });
    });
}

async function addColumnFilters(api) {
    const colCount = api.columns().count();

    for (let colIdx = 0; colIdx < colCount; colIdx++) {
        if (loadingCancelled) throw new Error('Loading cancelled by user.');

        const column = api.column(colIdx);
        const th = $('.filters th').eq(colIdx);
        const colName = column.header().textContent.trim();
        const colDef = activeColumnDetails[colName];

        if (!colDef) continue;

        // Create filter container
        const container = $('<div class="filter-container"></div>').appendTo(th);

        if (colDef.choices && colDef.choices.length > 0) {
            addCheckboxFilter(container, column, colDef);
        } else if (colDef.type === 'int' || colDef.type === 'float') {
            addRangeFilter(container, column, colDef);
        } else {
            addTextFilter(container, column);
        }

        await updateLoadingProgress("Adding Column Filters...", 70, 99, colIdx + 1, colCount);
        await yieldToBrowser();
    }

    // Setup hover expand/collapse
    setupFiltersExpandCollapse();
}

function setupFiltersExpandCollapse() {
    const table = document.querySelector('#csvTable');
    if (!table) return;

    const headerRow = table.querySelector('thead tr:first-child'); // column headers
    const filtersRow = table.querySelector('tr.filters');           // filters row

    if (!headerRow || !filtersRow) return;

    let isHoverHeader = false;
    let isHoverFilters = false;
    let isFocusInside = false;

    function updateFiltersState() {
        const shouldExpand = isHoverHeader || isHoverFilters || isFocusInside;
        filtersRow.classList.toggle('is-expanded', shouldExpand);
        filtersRow.classList.toggle('is-collapsed', !shouldExpand);
    }

    // Hover on headers
    headerRow.addEventListener('mouseenter', () => {
        isHoverHeader = true;
        updateFiltersState();
    });
    headerRow.addEventListener('mouseleave', () => {
        isHoverHeader = false;
        updateFiltersState();
    });

    // Hover on filters row itself (hover buffer)
    filtersRow.addEventListener('mouseenter', () => {
        isHoverFilters = true;
        updateFiltersState();
    });
    filtersRow.addEventListener('mouseleave', () => {
        isHoverFilters = false;
        updateFiltersState();
    });

    // Keep open while interacting
    filtersRow.addEventListener('focusin', () => {
        isFocusInside = true;
        updateFiltersState();
    });
    filtersRow.addEventListener('focusout', (e) => {
        const newTarget = e.relatedTarget;
        if (!filtersRow.contains(newTarget)) {
            isFocusInside = false;
            updateFiltersState();
        }
    });

    // Start collapsed
    updateFiltersState();
}

function ensureFiltersWrapper() {
    const filtersRow = document.querySelector('tr.filters');
    if (!filtersRow) return null;

    if (filtersRow.parentElement.classList.contains('filters-wrapper')) {
        return filtersRow.parentElement;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'filters-wrapper';

    filtersRow.parentElement.insertBefore(wrapper, filtersRow);
    wrapper.appendChild(filtersRow);

    return wrapper;
}

function addCheckboxFilter(th, column, colDef) {
    const box = $('<div class="filter-box"></div>').appendTo(th);
    const toggleAll = $('<label class="toggle-all-label"><input type="checkbox" class="toggle-all" checked> Toggle All</label>');
    box.append(toggleAll);

    colDef.choices.forEach(v => {
        box.append(`
            <label>
                <input type="checkbox" value="${v}" checked>
                ${v}
            </label>
        `);
    });

    // Toggle all
    box.on('change', '.toggle-all', function () {
        const checked = $(this).is(':checked');
        box.find('input[type="checkbox"]').not(this).prop('checked', checked).trigger('change');
    });

    // Individual checkbox filtering
    box.on('change', 'input:not(.toggle-all)', function () {
        const checkedVals = box.find('input[type="checkbox"]:not(.toggle-all):checked')
            .map((_, el) => $(el).val())
            .get();

        toggleAll.find('input').prop('checked', checkedVals.length === colDef.choices.length);

        let searchRegex;
        if (checkedVals.length === 0) {
            // No checkboxes checked ‚Üí match nothing
            searchRegex = 'a^'; // regex that never matches
        } else if (checkedVals.length === colDef.choices.length) {
            // All checked ‚Üí remove filter
            searchRegex = '';
        } else {
            // Some checked ‚Üí match only selected values
            searchRegex = '^(' + checkedVals.map(v => $.fn.dataTable.util.escapeRegex(v)).join('|') + ')$';
        }

        column.search(searchRegex, true, false).draw();
    });
}

function addTextFilter(th, column) {
    $('<input type="text" class="filter-text" placeholder="Filter..." />')
        .appendTo(th)
        .on('keyup change clear', function () {
            column.search(this.value).draw();
        });
}

function addRangeFilter(th, column, colDef) {
    // container
    const box = $('<div class="filter-range"></div>').appendTo(th);

    // labeled inputs
    const minWrapper = $('<div class="range-input-wrapper"></div>').appendTo(box);
    $('<label class="range-label">Min</label>').appendTo(minWrapper);
    const minInput = $('<input type="number" class="range-min" placeholder="Min" />')
        .val(colDef.min ?? '')
        .appendTo(minWrapper);

    const maxWrapper = $('<div class="range-input-wrapper"></div>').appendTo(box);
    $('<label class="range-label">Max</label>').appendTo(maxWrapper);
    const maxInput = $('<input type="number" class="range-max" placeholder="Max" />')
        .val(colDef.max ?? '')
        .appendTo(maxWrapper);

    const colIdx = column.index();
    const dataKey = column.dataSrc();
    const table = column.table();
    let lastFilterName = null;

    function stripHtml(text) {
        if (typeof text !== 'string') return text;
        const tmp = document.createElement('div');
        tmp.innerHTML = text;
        return (tmp.textContent || tmp.innerText || '').trim();
    }

    function applyRangeFilter() {
        const minVal = minInput.val() === '' ? NaN : parseFloat(minInput.val());
        const maxVal = maxInput.val() === '' ? NaN : parseFloat(maxInput.val());

        if (lastFilterName) {
            $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(fn => fn.name !== lastFilterName);
            lastFilterName = null;
        }

        const rangeFilter = function(settings, data) {
            let rawVal;
            if (data == null) rawVal = undefined;
            else if (typeof data === 'object' && !Array.isArray(data)) rawVal = data[dataKey];
            else if (Array.isArray(data)) rawVal = data[colIdx];
            else rawVal = data;

            const num = parseFloat(String(stripHtml(rawVal)).replace(/,/g, '').trim());
            if (isNaN(num)) return true;
            if (!isNaN(minVal) && num < minVal) return false;
            if (!isNaN(maxVal) && num > maxVal) return false;
            return true;
        };

        rangeFilter.name = `rangeFilter_${colIdx}_${Date.now()}`;
        lastFilterName = rangeFilter.name;
        $.fn.dataTable.ext.search.push(rangeFilter);

        table.draw();
    }

    box.on('input change', 'input', applyRangeFilter);
    applyRangeFilter();
}


async function addSortingControls(api, dt) {
    const totalSortingSteps = csvTableElement.find('thead tr:first-child th').length;

    csvTableElement.find('thead tr:first-child th').each(async function (index) {
        const th = $(this);

        // Only add buttons once
        if (!th.find('.sort-asc').length) {
            const title = th.text().trim();
            th.html(`
                ${title}
                <button class="sort-asc btn" data-col="${index}">‚Üë</button>
                <button class="sort-desc btn" data-col="${index}">‚Üì</button>
            `);
        }
    });

    // Attach click handlers (if not already attached)
    if (!csvTableElement.data('sortingButtonsBound')) {
        csvTableElement.on('click', '.sort-asc', function () {
            dt.order([$(this).data('col'), 'asc']).draw();
        });

        csvTableElement.on('click', '.sort-desc', function () {
            dt.order([$(this).data('col'), 'desc']).draw();
        });

        csvTableElement.data('sortingButtonsBound', true);
    }
}

function renderCellValue(val, colName = null) {
    if (val === undefined || val === null) return '';

    // Non-string values can be returned directly
    const text = String(val).trim();

    const toFileUrl = path => {
        if (path.startsWith('http')) return path;
        let urlPath = path.replace(/\\/g, '/');
        if (!urlPath.startsWith('/')) urlPath = '/' + urlPath;
        return 'file:///' + urlPath;
    };

    // Excel-style HYPERLINK formula
    const hyperlinkMatch = text.match(/^=HYPERLINK\("([^"]+)",\s*"([^"]+)"\)$/i);
    if (hyperlinkMatch) {
        const [, rawPath, label] = hyperlinkMatch;
        return `<a href="${toFileUrl(rawPath)}" target="_blank">${label}</a>`;
    }

    // Web URLs
    if (/^https?:\/\//i.test(text)) return `<a href="${text}" target="_blank">${text}</a>`;

    // Local Windows path
    if (/^[a-zA-Z]:\\/.test(text)) return `<a href="${toFileUrl(text)}" target="_blank">${text}</a>`;

    // Highlight numeric columns automatically
    if (colName && activeColumnDetails[colName] && ['int', 'float'].includes(activeColumnDetails[colName].type)) {
        const { min, max } = activeColumnDetails[colName];
        return highlightValue(text, min, max);
    }

    return text;
}

function highlightValue(val, min, max) {
    const num = parseFloat(val);
    if (isNaN(num)) return val;

    // Compute intensity 0 ‚Üí 1
    const intensity = Math.max(0, Math.min(1, (num - min) / (max - min)));

    const isLightMode = document.body.classList.contains('light-theme');

    // --- Four fixed extremes ---
    let low, high;
    if (isLightMode) {
        // Light mode: black text, red ‚Üí green
        low  = { h: 0,   s: 70, l: 80 };  // light red
        high = { h: 120, s: 70, l: 80 };  // light green (readable on black)
    } else {
        // Dark mode: white text, red ‚Üí green
        low  = { h: 0,   s: 70, l: 20 };  // dark red
        high = { h: 120, s: 70, l: 20 };  // dark green (readable on white)
    }

    // Interpolate HSL between low and high
    const hue = Math.round(low.h + (high.h - low.h) * intensity);
    const saturation = Math.round(low.s + (high.s - low.s) * intensity);
    const lightness = Math.round(low.l + (high.l - low.l) * intensity);
    const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    const textColor = isLightMode ? '#000000' : '#ffffff';
    const weightClass = intensity > 0.7 ? 'high' : intensity > 0.4 ? 'medium' : 'low';
    return `<span class="highlight-cell ${weightClass}" style="background-color:${bgColor}; color:${textColor}">${val}</span>`;
}

async function showPrefilterOverlayAndCollectFilters(activeColumnDetails) {
    try {
        const overlay = createPrefilterOverlayContainer('Refine Your Search');
        overlay.appendChild(createPrefilterNotice());

        const form = document.createElement('form');

        form.appendChild(createPrefilterActions());
        form.appendChild(createPrefilterGridFromColumnDetails(activeColumnDetails));

        overlay.appendChild(form);
        document.body.appendChild(overlay);

        return new Promise(resolve =>
            waitForPrefilterFormSubmission(form, resolve, overlay)
        );
    } catch (err) {
        console.warn('Prefilter UI failed, continuing without prefiltering:', err);
        return {};
    }
}

function createPrefilterOverlayContainer(title) {
    const overlay = document.createElement('div');
    overlay.id = 'prefilterOverlay';
    overlay.className = 'prefilter-overlay';
    overlay.innerHTML = `<h2>${title}</h2>`;
    return overlay;
}

function createPrefilterNotice() {
    const notice = document.createElement('div');
    notice.className = 'prefilter-notice';
    notice.innerHTML = `
        ‚ö† <strong>Important: Use Prefilters to Reduce Load</strong><br>
        The tool loads the entire dataset captured from the site, which can be very large. 
        Unless you use prefilters to narrow it down, your browser may take a long time to load the data, 
        and it can become very memory-intensive.<br><br>
        All processing happens client-side ‚Äî this is just a static webpage running in your browser. 
        You‚Äôll see a ‚ÄúLoading Data‚Ä¶‚Äù overlay while it loads.<br><br>
        <strong>To improve performance:</strong>
        <ul>
            <li>Use the prefilters to limit the number of rows loaded.</li>
            <li>Start with broad filters and refine them gradually if needed.</li>
            <li>If loading becomes too slow, stop the processing, refresh the page and adjust your prefilters.</li>
        </ul>
        Proper use of prefilters ensures a faster, smoother experience when exploring the table.
    `;
    return notice;
}

function createPrefilterActions() {
    const actions = document.createElement('div');
    actions.className = 'prefilter-actions sticky-top';
    actions.appendChild(createPrefilterSubmitButton('Apply Filters & Search'));
    return actions;
}

function createPrefilterSubmitButton(label = 'Submit') {
    const btn = document.createElement('button');
    btn.type = 'submit';
    btn.textContent = label;
    btn.className = 'btn';
    return btn;
}

function createPrefilterGridFromColumnDetails(columnDetails) {
    const grid = document.createElement('div');
    grid.className = 'prefilter-form';
    for (const [col, colDef] of Object.entries(columnDetails)) {
        grid.appendChild(createFilterSectionForColumnDetails(col, colDef));
    }
    return grid;
}

// Section for a column, decides which small helper to call
function createFilterSectionForColumnDetails(col, colDef) {
    const section = document.createElement('section');
    section.className = 'filter-section';

    const title = document.createElement('h3');
    title.textContent = col;
    section.appendChild(title);

    if (colDef.type === 'tag') {
        section.appendChild(createTagFilter(col));
    } else if (Array.isArray(colDef.choices) && colDef.choices.length > 0) {
        section.appendChild(createChoiceFilter(col, colDef.choices));
    } else if (colDef.type === 'int' || colDef.type === 'float') {
        section.appendChild(createRangeFilter(col, colDef.min, colDef.max));
    } else {
        section.appendChild(createTextFilterInput(col));
    }

    return section;
}

// Choice checkbox group with toggle-all
function createChoiceFilter(name, choices) {
    const box = document.createElement('div');
    box.className = 'filter-box';

    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'toggle-all-label';
    toggleLabel.innerHTML = `<input type="checkbox" class="toggle-all" data-col="${name}" checked> Toggle All`;
    box.appendChild(toggleLabel);

    choices.forEach(choice => {
        const lbl = document.createElement('label');
        lbl.className = 'filter-checkbox';
        const inp = document.createElement('input');
        inp.type = 'checkbox';
        inp.name = name;
        inp.value = String(choice);
        inp.checked = true;
        lbl.appendChild(inp);
        lbl.appendChild(document.createTextNode(' ' + String(choice)));
        box.appendChild(lbl);
    });

    toggleLabel.querySelector('input').addEventListener('change', function () {
        const checked = this.checked;
        box.querySelectorAll(`input[name="${name}"]`).forEach(i => i.checked = checked);
    });

    return box;
}

// Tag checkboxes
function createTagFilter(name) {
    const container = document.createElement('div');
    container.className = 'filter-tag-group';

    // 0 checkbox
    const lbl0 = document.createElement('label');
    lbl0.className = 'filter-checkbox';
    const inp0 = document.createElement('input');
    inp0.type = 'checkbox';
    inp0.name = name;
    inp0.value = '0';
    inp0.checked = false;
    lbl0.appendChild(inp0);
    lbl0.appendChild(document.createTextNode(' No (0)'));

    // 1 checkbox
    const lbl1 = document.createElement('label');
    lbl1.className = 'filter-checkbox';
    const inp1 = document.createElement('input');
    inp1.type = 'checkbox';
    inp1.name = name;
    inp1.value = '1';
    inp1.checked = false;
    lbl1.appendChild(inp1);
    lbl1.appendChild(document.createTextNode(' Yes (1)'));

    container.appendChild(lbl0);
    container.appendChild(lbl1);

    return container;
}

// Range filter (min / max inputs) ‚Äî sleek version
function createRangeFilter(name, min = null, max = null) {
    const wrapper = document.createElement('div');
    wrapper.className = 'filter-range';

    const minWrap = document.createElement('div');
    minWrap.className = 'range-input-wrapper';
    // Use placeholder (if available) instead of pre-filling the value.
    minWrap.appendChild(createNumberInput(`${name}__min`, null, 'Min', 'range-min', (min != null ? String(min) : '')));

    const maxWrap = document.createElement('div');
    maxWrap.className = 'range-input-wrapper';
    maxWrap.appendChild(createNumberInput(`${name}__max`, null, 'Max', 'range-max', (max != null ? String(max) : '')));

    wrapper.appendChild(minWrap);
    wrapper.appendChild(maxWrap);
    return wrapper;
}

// Create labeled number input with optional class for styling
function createNumberInput(name, value = null, labelText = '', inputClass = '', placeholder = '') {
    const container = document.createElement('div');

    const label = document.createElement('label');
    label.className = 'range-label';
    label.textContent = labelText;
    container.appendChild(label);

    const input = document.createElement('input');
    input.type = 'number';
    input.name = name;

    if (value !== null && value !== undefined && value !== '') {
        input.value = value;
    } else if (placeholder) {
        input.placeholder = placeholder;
    }

    if (inputClass) input.className = inputClass;

    input.step = 'any';
    input.min = '';
    input.max = '';

    input.addEventListener('invalid', e => e.preventDefault());

    container.appendChild(input);
    return container;
}

// Text input filter (fallback)
function createTextFilterInput(name) {
    const input = document.createElement('input');
    input.type = 'text';
    input.name = name;
    input.placeholder = `Filter ${name}‚Ä¶`;
    return input;
}

// Wait for prefilter form submission
function waitForPrefilterFormSubmission(form, resolve, overlay) {
    form.addEventListener('submit', e => {
        e.preventDefault();
        const preFilter = collectPrefilterFromForm(form);
        overlay.remove();
        resolve(preFilter);
    });
}

// Main entry: returns the structured preFilter
function collectPrefilterFromForm(form) {
    const preFilter = {};
    processRangeColumns(form, preFilter);
    processTagColumns(form, preFilter);
    processChoiceColumns(form, preFilter);
    processTextColumns(form, preFilter);
    return preFilter;
}

// Process range columns
function processRangeColumns(form, preFilter, colDefMap = activeColumnDetails) {
    Object.entries(colDefMap).forEach(([col, def]) => {
        if (def.type !== 'int' && def.type !== 'float') return;

        const minEl = form.querySelector(`[name="${col}__min"]`);
        const maxEl = form.querySelector(`[name="${col}__max"]`);

        if (!minEl && !maxEl) return;

        let min = minEl?.value === '' ? null : Number(minEl.value);
        let max = maxEl?.value === '' ? null : Number(maxEl.value);

        if (def.type === 'int') {
            if (min != null) min = Math.round(min);
            if (max != null) max = Math.round(max);
        }

        if (min != null || max != null) {
            preFilter[col] = { type: def.type, min, max };
        }
    });
}

// Build tag entries in preFilter
function processTagColumns(form, preFilter, colDefMap = activeColumnDetails) {
    Object.entries(colDefMap).forEach(([col, def]) => {
        if (def.type !== 'tag') return;

        const checkboxes = Array.from(form.querySelectorAll(`input[type="checkbox"][name="${col}"]`));
        if (checkboxes.length === 0) return;

        const checked = checkboxes.filter(c => c.checked).map(c => Number(c.value));
        if (checked.length === 0 || checked.length === def.choices.length) return;

        preFilter[col] = { type: 'tag', choices: checked };
    });
}

// Process choice checkboxes
function processChoiceColumns(form, preFilter, colDefMap = activeColumnDetails) {
    Object.entries(colDefMap).forEach(([col, def]) => {
        if (!Array.isArray(def.choices) || def.choices.length === 0) return;
        if (def.type === 'tag') return;

        const checkboxes = Array.from(form.querySelectorAll(`input[type="checkbox"][name="${col}"]`));
        if (checkboxes.length === 0) return;

        const checked = checkboxes
            .filter(c => c.checked)
            .map(c => {
                if (def.type === 'bool') return c.value === 'true';
                if (def.type === 'int') return parseInt(c.value, 10);
                if (def.type === 'float') return parseFloat(c.value);
                return String(c.value);
            });

        if (checked.length === 0 || checked.length === def.choices.length) return;
        preFilter[col] = { type: def.type, choices: checked };
    });
}

// Process text inputs
function processTextColumns(form, preFilter) {
    const inputs = Array.from(form.querySelectorAll('input[type="text"], textarea'));
    for (const input of inputs) {
        const val = input.value.trim();
        if (!val) continue;
        preFilter[input.name] = { text: [val] };
    }
}


function loadAndUpdateTheme() {
    // Load saved theme
    if (localStorage.getItem('theme') === 'light') {
        document.body.classList.add('light-theme');
    }
    updateThemeButton()
}

function updateThemeButton() {
    const isLight = document.body.classList.contains('light-theme');
    themeToggleButton.textContent = isLight ? 'üåû Light' : 'üåô Dark';
}


loadAndUpdateTheme();


// Search button
searchButton.addEventListener('click', async () => {
    if (!activeCsvFile) return alert('No CSV file loaded yet.');
    if (!activeColumnDetails || Object.keys(activeColumnDetails).length === 0) return alert('No column details json loaded yet.');
    await executeCsvSearchWithRetries();
});

// Reset filters button
resetFiltersButton.addEventListener('click', () => {
    if (!$.fn.DataTable.isDataTable(csvTableElement)) return;

    const dt = csvTableElement.DataTable();

    // Reset column searches
    dt.columns().every(function() {
        this.search('');
    });

    // Reset checkboxes
    $('.filter-box input[type="checkbox"]').prop('checked', true);

    // Reset text inputs
    $('.filter-text').val('');

    // Reset column order
    if (dt.colReorder) dt.colReorder.reset();

    // Reset sorting
    dt.order([]).draw(); // only one redraw here
});

// Theme toggle button
themeToggleButton.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    updateThemeButton();
});

// Stop loading button
stopLoadingButton.addEventListener('click', () => {
    cancelLoading();
    hideLoading();
});


</script>








<!-- Code injected for standalone web deployment -->
<script>
(async () => {
    await loadDefaultCsv();
    await loadDefaultColumnDetailsJson();
    await executeCsvSearchWithRetries();
})();
</script>



<!--
<script>
(async () => {
    await loadDefaultCsv();
    await loadDefaultColumnDetailsJson();
    await executeCsvSearchWithRetries();
})();
</script>
-->


</body>
</html>
