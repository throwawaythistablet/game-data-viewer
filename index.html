<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Table from CSV</title>

    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/colreorder/1.6.2/css/colReorder.dataTables.min.css">

    <style>

        /* =========================================================
           THEME VARIABLES
           ========================================================= */
        :root {
            --bg-main: #121212;
            --bg-panel: #1e1e1e;
            --bg-elevated: #252525;
            --bg-hover: #2f2f2f;

            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;

            --border-subtle: #333;
            --border-strong: #444;

            --accent: #4dabf7;
            --accent-hover: #339af0;

            --danger: #ff6b6b;
        }

        body.light-theme {
            --bg-main: #f8f9fa;
            --bg-panel: #ffffff;
            --bg-elevated: #f1f3f5;
            --bg-hover: #e9ecef;

            --text-main: #212529;
            --text-muted: #6c757d;

            --border-subtle: #ced4da;
            --border-strong: #adb5bd;

            --accent: #007bff;
            --accent-hover: #0056b3;
        }

        /* =========================================================
           BASE LAYOUT
           ========================================================= */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: var(--bg-main);
            color: var(--text-main);
        }

        table {
            width: 100%;
            background: var(--bg-panel);
            color: var(--text-main);
        }

        /* =========================================================
           CONTROLS / TOOLBAR
           ========================================================= */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: var(--bg-panel);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        /* Top bar: Title and Main Actions */
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls-title {
            margin: 0;
            font-size: 22px;
            letter-spacing: -0.5px;
        }

        .controls-main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: stretch;
            transition:
                max-height 0.22s ease,
                opacity 0.18s ease,
                transform 0.18s ease;
            overflow: hidden;
        }

        /* Collapsed state (after CSV load) */
        .controls-main-grid.is-collapsed {
            max-height: 0;
            opacity: 0;
            transform: translateY(-4px);
            pointer-events: none;
        }

        /* Expanded state (hover or pinned) */
        .controls-main-grid.is-expanded {
            max-height: 800px; /* comfortably larger than content */
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        /* Pin button active state remains same */
        #controlsPinBtn.is-active {
            background: var(--accent);
            color: var(--bg-main);
        }

        @media (max-width: 768px) {
            .controls-main-grid { grid-template-columns: 1fr; }
        }

        /* Info Cards */
        .status-card {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .controls-value {
            text-align: right;
            max-width: 70%; 
            color: var(--accent);
            font-weight: bold;
            
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            
            display: inline-block;
            vertical-align: middle;
        }

        .controls-status-item {
            display: flex;
            justify-content: space-between;
            font-size: 15px;
            border-bottom: 1px solid var(--border-subtle);
            padding-bottom: 4px;
        }

        .controls-status-item:last-child { border: none; }

        /* =========================================================
           DROP ZONE
           ========================================================= */
        #dropZone {
            background: var(--bg-elevated);
            border: 2px dashed var(--border-strong);
            color: var(--text-muted);
            padding: 16px; 
            text-align: center;
            border-radius: 5px;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%; 
            box-sizing: border-box; 
        }
        
        #dropZone.dragover {
            background-color: #162233;
            color: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        
        #dropZone:hover {
            transform: scale(1.02);
            border-color: var(--accent);
            color: var(--accent);
            background: var(--bg-hover);
        }

        /* =========================================================
           BUTTONS
           ========================================================= */
        .btn {
            background: var(--accent);
            color: var(--bg-main);
            padding: 6px 14px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            height: 38px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-strong);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn:hover {
            background: var(--accent-hover);
        }

        /* Hide default file input */
        #csvFile {
            display: none;
        }

        #fileBtn {
            margin-right: 0;
        }

        /* =========================================================
           TABLE FILTERS
           ========================================================= */
        .filters th {
            vertical-align: top;
            padding: 4px;
        }

        /* Checkbox filter */
        .filter-box {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            max-height: 180px;
            overflow-y: auto;
            padding: 4px;
            font-size: 12px;
        }

        .filter-box label {
            display: block;
            cursor: pointer;
            white-space: nowrap;
        }

        .filter-box input {
            margin-right: 4px;
        }

        /* Text filter */
        .filter-text {
            background: var(--bg-elevated);
            color: var(--text-main);
            border: 1px solid var(--border-subtle);
            width: 100%;
            box-sizing: border-box;
            font-size: 12px;
            padding: 4px;
        }

        /* =========================================================
           SORTING BUTTONS (TABLE HEADERS)
           ========================================================= */
        th .sort-asc,
        th .sort-desc {
            font-size: 10px;
            padding: 2px 4px;
            margin-left: 4px;
            border-radius: 3px;
            background: var(--accent);
            color: var(--bg-main);
            cursor: pointer;
            height: auto;
            line-height: 1;
            min-width: 0;
            display: inline-block;
            transition: background 0.2s;
        }

        th .sort-asc:hover,
        th .sort-desc:hover {
            background: var(--accent-hover);
        }

        .highlight-cell {
            display: block;
            padding: 2px 4px;
            border-radius: 2px;
            text-align: center;
            font-weight: normal;
            transition: background-color 0.2s, font-weight 0.2s;
        }

        .highlight-cell.low { font-weight: normal; }
        .highlight-cell.medium { font-weight: 500; }
        .highlight-cell.high { font-weight: bold; }

        body.light-mode .highlight-cell { color: black; }
        body.dark-mode  .highlight-cell { color: white; }

/* =========================================================
   PREFILTER OVERLAY
   ========================================================= */
#prefilterOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 1000;

    display: flex;
    flex-direction: column;
    align-items: center;

    padding: 24px;
    color: #eee;

    /* single vertical scrollbar for overlay */
    overflow-y: auto;
    overflow-x: hidden;
}

.prefilter-form {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 16px;

    width: 100%;
    max-width: 1400px;

    /* grid itself does not scroll */
    overflow: visible;
}

/* Cards with capped height */
.filter-section {
    background: #1c1c1c;
    border: 1px solid #333;
    border-radius: 6px;
    padding: 12px;

    display: flex;
    flex-direction: column;

    /* max height for long cards */
    max-height: 180px;
    overflow: hidden;
}

.filter-section h3 {
    margin: 0 0 6px;
    font-size: 14px;
    font-weight: 600;
    flex-shrink: 0;
}

/* Values scroll only when needed */
.filter-values {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 6px;
    overflow-y: auto;

    /* critical for flex/grid shrink behavior */
    min-height: 0;
    min-width: 0;
}

/* Checkbox layout with text wrapping */
.filter-checkbox {
    font-size: 12px;
    display: flex;
    gap: 6px;
    align-items: flex-start; /* allow multi-line labels */
    min-height: 20px;
    line-height: 1.2;

    /* text wrapping */
    min-width: 0;
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
}

/* Prevent checkbox shrinking */
.filter-checkbox input {
    flex-shrink: 0;
    margin-top: 2px;
}

/* Text input filters behave normally */
.filter-section input[type="text"] {
    width: 100%;
    padding: 6px;
    background: #111;
    border: 1px solid #444;
    color: #eee;
    border-radius: 4px;
    box-sizing: border-box;
}

/* Footer */
.prefilter-actions {
    width: 100%;
    max-width: 1400px;
    display: flex;
    justify-content: center;
    padding: 16px 0;
    flex-shrink: 0;
}

.prefilter-actions button {
    padding: 10px 24px;
    font-size: 15px;
    cursor: pointer;
}






        /* =========================================================
           LOADING OVERLAY & PROGRESS
           ========================================================= */
        #loadingOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 999;
            background: rgba(0,0,0,0.85);
            color: var(--accent);
            font-size: 18px;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin-top: 10px;
            border-radius: 50%;
            border: 6px solid #eee;
            border-top: 6px solid var(--accent);
            animation: spin 0.5s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to   { transform: rotate(360deg); }
        }

        /* Progress bar */
        #csvProgressBarContainer {
            width: 80%;
            margin-top: 15px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #csvProgressBar {
            width: 0%;
            height: 20px;
            background: var(--accent);
            transition: width 0.1s;
        }

        #csvProgressText {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }

        /* =========================================================
           IMAGE MODAL
           ========================================================= */
        #imageModal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.95);
            color: white;
            flex-direction: column;
        }

        #imageModalHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #111;
        }

        #imageModalGrid {
            flex-grow: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            overflow-y: auto;
        }

        #imageModalGrid img {
            width: 100%;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Fullscreen image preview */
        #imageOverlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: rgba(0,0,0,0.9);
            align-items: center;
            justify-content: center;
        }

        #imageOverlay img {
            max-width: 90%;
            max-height: 90%;
        }
    </style>

</head>
<body>


<div class="controls">
    <div class="controls-header">
        <h2 class="controls-title">Games Analysis</h2>
        <div class="btn-group">
            <button id="themeToggleBtn" class="btn btn-secondary" title="Toggle between light and dark theme">ðŸŒ™ Dark</button>
            <button id="resetFiltersBtn" class="btn" title="Reset all filters and sorting to their default state">ðŸ”„ Reset Filters</button>
        </div>
    </div>



</div>


<table id="csvTable" class="display"></table>

<div id="loadingOverlay">
    <div>Loading Data...</div>
    <div class="spinner"></div>
    <div id="csvProgressBarContainer">
        <div id="csvProgressBar"></div>
        <span id="csvProgressText">0%</span>
    </div>
</div>




<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/colreorder/1.6.2/js/dataTables.colReorder.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>





<script>


const tableElement = $('#csvTable');
const themeToggleBtn = document.getElementById('themeToggleBtn');
const resetFiltersBtn = document.getElementById('resetFiltersBtn')
const loadingOverlay = document.getElementById('loadingOverlay');
const progressBarEl = document.getElementById('csvProgressBar');
const progressTextEl = document.getElementById('csvProgressText');

let prefilters = {};


function showLoading() { loadingOverlay.style.display = 'flex'; }

function hideLoading() { loadingOverlay.style.display = 'none'; }

async function yieldToBrowser() {
    await new Promise(r => setTimeout(r, 0)); // OLD
    // if (!document.hidden) await new Promise(r => setTimeout(r, 0));
}

async function updateLoadingProgress(startPercent, endPercent, currentStep, totalSteps) {
    if (totalSteps <= 0) totalSteps = 1;

    const fractionOfPhase = currentStep / totalSteps;
    const totalPercent = startPercent + fractionOfPhase * (endPercent - startPercent);

    progressBarEl.style.width = totalPercent + '%';
    if (progressTextEl) progressTextEl.textContent = totalPercent.toFixed(2) + '%';

    //console.log(`Progress: ${totalPercent.toFixed(2)}% | Step: ${currentStep}/${totalSteps} | Phase: ${startPercent} â†’ ${endPercent}%`); // debug

    await yieldToBrowser();
}

async function loadCsv(input) {
    if (!input) return false;

    try {
        const { file, totalSize } = await prepareFile(input);
        if (!file) throw new Error('File preparation failed');

        const loadedPreFilters = await loadPreFilters();
        const builtPreFilters =
            loadedPreFilters && Object.keys(loadedPreFilters).length > 0
                ? await buildPrefilterUi(loadedPreFilters)
                : {};

        await updateLoadingProgress(0, 0, 0, 1);
        showLoading();

        const parsedData = await parseCsv(file, totalSize, builtPreFilters);

        if (!Array.isArray(parsedData) || parsedData.length === 0) {
            throw new Error('No rows loaded');
        }

        const columns = buildColumnsFromData(parsedData);
        await buildDataTable(parsedData, columns);

        return true; // âœ… SUCCESS
    } catch (err) {
        console.error('loadCsv failed:', err);
        alert(err.message || 'Failed to load data');
        return false; // âŒ FAILURE
    } finally {
        hideLoading();
        await updateLoadingProgress(0, 0, 0, 1);
    }
}


async function prepareFile(input) {
    let file, totalSize;
    if (typeof input === 'string') {
        file = new Blob([input], { type: 'text/csv' });
        totalSize = file.size;
    } else {
        file = input;
        totalSize = input.size;
    }
    return { file, totalSize };
}

async function loadPreFilters() {
    try {
        if (prefilters && Object.keys(prefilters).length) return prefilters;

        const urls = ['./data/game_prefilters.json', './game_prefilters.json'];
        for (const url of urls) {
            try {
                const response = await fetch(url);
                if (!response.ok) continue;
                const json = await response.json();
                prefilters = json;
                return json;
            } catch (err) {
                console.warn(`Could not fetch ${url}:`, err);
            }
        }

        prefilters = {};
        updatePrefilterFilename(null);
        return {};
    } catch (err) {
        console.warn('Prefilters could not be loaded, continuing without prefiltering:', err);
        return {};
    }
}


async function parseCsv(file, totalSize, preFilter) {
    const parsedData = [];
    let rowsProcessed = 0;
    let bytesProcessed = 0;
    const THROTTLE = 100;
    const MAX_ROWS = 10000; // maximum rows to prevent memory overload

    return new Promise((resolve, reject) => {
        Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            worker: true,
            step: function (row) {
                // Add row if passes prefilter
                if (!preFilter || Object.keys(preFilter).length === 0 || rowPassesPreFilter(row.data, preFilter)) {
                    parsedData.push(row.data);
                }

                rowsProcessed++;
                bytesProcessed += new TextEncoder().encode(Object.values(row.data).join(',') + '\n').length;

                // Throttle progress updates
                if (rowsProcessed % THROTTLE === 0) {
                    updateLoadingProgress(0, 30, bytesProcessed, totalSize);
                }

                // Stop if max rows exceeded
                if (parsedData.length >= MAX_ROWS) {
                    // Throwing inside step will terminate the worker and call the error callback
                    throw new Error(
                        `Too many items loaded (${MAX_ROWS}). Please use filters to reduce the number of items before loading.`
                    );
                }
            },
            complete: function () {
                updateLoadingProgress(0, 30, totalSize, totalSize);
                resolve(parsedData);
            },
            error: function (err) {
                reject(err);
            }
        });
    });
}

function rowPassesPreFilter(row, preFilter) {
    return Object.entries(preFilter).every(([col, allowedValues]) => {
        const rawVal = row[col];
        const val = rawVal != null ? String(rawVal).trim() : '';

        // Empty or invalid allowedValues or empty string â†’ allow all
        if (!Array.isArray(allowedValues) || allowedValues.length === 0 || val === "") {
            return true;
        }

        // Check if value is allowed
        return allowedValues.includes(val);
    });
}

function buildColumnsFromData(parsedData) {
    if (!parsedData || !parsedData.length) return [];

    const keys = Object.keys(parsedData[0]);
    const columns = keys.map(key => ({
        title: key,
        data: key,
        render: (data, type, row, meta) => renderCellValue(data, key)
    }));

    // Add the "View Images" column if "location" exists
    if (keys.includes('location')) {
        columns.unshift({
            title: 'View Images',
            data: '__view_images__', // reserved key
            orderable: false,
            searchable: false,
            render: (data, type, row, meta) => {
                return `<button class="btn view-images">View</button>`;
            }
        });
    }

    return columns;
}

async function buildDataTable(data, columns) {
    showLoading();
    
    tableElement.hide();
    
    destroyExistingTable();
    buildTableHeader(columns);
    const tbody = buildTableBody();
    await insertRowsInChunks(data, columns, tbody);
    await initializeDataTable(columns);
    
    tableElement.show();
    await updateLoadingProgress(100, 100, 1, 1);
    hideLoading();
}

function destroyExistingTable() {
    try {
        if ($.fn.DataTable.isDataTable(tableElement)) {
            tableElement.DataTable().destroy();
        }
    } catch (e) {
        console.warn('Failed to destroy existing DataTable:', e);
    } finally {
        tableElement.empty(); // clear old header/body safely
    }
}

function buildTableHeader(columns) {
    const thead = $('<thead>');
    const headerRow = $('<tr>');
    const filterRow = $('<tr class="filters">');

    columns.forEach(col => {
        headerRow.append(`<th>${col.title}</th>`);
        filterRow.append('<th></th>');
    });

    thead.append(headerRow).append(filterRow);
    tableElement.append(thead);
}

function buildTableBody() {
    const tbody = $('<tbody>');
    tableElement.append(tbody);
    return tbody;
}

async function insertRowsInChunks(data, columns, tbody) {
    const CHUNK_SIZE = 500;

    for (let start = 0; start < data.length; start += CHUNK_SIZE) {
        const chunk = data.slice(start, start + CHUNK_SIZE);
        const fragment = document.createDocumentFragment();

        chunk.forEach(rowData => {
            const tr = document.createElement('tr');

            // Render cells based on column definitions
            columns.forEach(col => {
                const td = document.createElement('td');

                if (col.data === '__view_images__') {
                    td.innerHTML = `<button class="btn view-images">View</button>`;
                } else {
                    td.innerHTML = renderCellValue(rowData[col.data], col.data);
                }

                tr.appendChild(td);
            });

            fragment.appendChild(tr);
        });

        tbody[0].appendChild(fragment);

        await updateLoadingProgress(30, 60, Math.min(start + CHUNK_SIZE, data.length), data.length);
        await yieldToBrowser();
    }
}

function initializeDataTable(columns) {
    return new Promise(resolve => {

        const dt = tableElement.DataTable({
            paging: true,
            pageLength: 100,
            lengthMenu: [
                [50, 100, 200, 500, 1000],
                [50, 100, 200, 500, 1000]
            ],
            fixedHeader: true,
            colReorder: true,
            autoWidth: false,
            orderCellsTop: true,

            dom: '<"top"lfip>rt<"bottom"lfip><"clear">',

            initComplete: async function () {
                const api = this.api();

                await buildColumnFilters(api);
                await addSortingButtons(api, dt);

                resolve(); // EVERYTHING IS REALLY DONE NOW
            }
        });
    });
}


async function buildColumnFilters(api) {
    const colCount = api.columns().count();

    for (let colIdx = 0; colIdx < colCount; colIdx++) {
        const column = api.column(colIdx);
        const cell = $('.filters th').eq(colIdx);

        // Collect unique values
        const values = new Set();
        column.data().each(val => {
            const clean = $('<div>').html(val).text().trim();
            values.add(clean || '(Blanks)');
        });

        const sorted = Array.from(values).sort();

        if (sorted.length <= 20) {
            const box = $('<div class="filter-box"></div>').appendTo(cell);

            // Add "Select All / Uncheck All" checkbox at the top
            const selectAll = $(`<label><input type="checkbox" class="select-all" checked> Toggle All</label>`);
            box.append(selectAll);

            sorted.forEach(v => {
                box.append(`
                    <label>
                        <input type="checkbox" value="${v}" checked>
                        ${v}
                    </label>
                `);
            });

            // Event: toggle all checkboxes
            box.on('change', '.select-all', function () {
                const checked = $(this).is(':checked');
                box.find('input[type="checkbox"]').not(this).prop('checked', checked).trigger('change');
            });

            // Event: individual checkboxes
            box.on('change', 'input:not(.select-all)', function () {
                const checkedVals = box.find('input[type="checkbox"]:not(.select-all):checked')
                    .map((_, el) => $(el).val())
                    .get();

                // Update "Select All" checkbox based on individual checkboxes
                selectAll.find('input').prop('checked', checkedVals.length === sorted.length);

                // Apply filtering
                if (checkedVals.length === 0 || checkedVals.length === sorted.length) {
                    column.search('').draw(); // show all if nothing or all selected
                    return;
                }

                const regex = '^(' + checkedVals.map(v =>
                    v === '(Blanks)' ? '' : $.fn.dataTable.util.escapeRegex(v)
                ).join('|') + ')$';

                column.search(regex, true, false).draw();
            });
        } else {
            $('<input type="text" class="filter-text" placeholder="Filter..." />')
                .appendTo(cell)
                .on('keyup change clear', function () {
                    column.search(this.value).draw();
                });
        }

        await updateLoadingProgress(60, 90, colIdx + 1, colCount);
        await yieldToBrowser();
    }
}

async function addSortingButtons(api, dt) {
    const totalSortingSteps = tableElement.find('thead tr:first-child th').length;

    tableElement.find('thead tr:first-child th').each(async function (index) {
        const th = $(this);

        // Only add buttons once
        if (!th.find('.sort-asc').length) {
            const title = th.text().trim();
            th.html(`
                ${title}
                <button class="sort-asc btn" data-col="${index}">â†‘</button>
                <button class="sort-desc btn" data-col="${index}">â†“</button>
            `);
        }

        // Update progress
        await updateLoadingProgress(90, 100, index + 1, totalSortingSteps);
    });

    // Attach click handlers (if not already attached)
    if (!tableElement.data('sortingButtonsBound')) {
        tableElement.on('click', '.sort-asc', function () {
            dt.order([$(this).data('col'), 'asc']).draw();
        });

        tableElement.on('click', '.sort-desc', function () {
            dt.order([$(this).data('col'), 'desc']).draw();
        });

        tableElement.data('sortingButtonsBound', true);
    }
}

const HIGHLIGHT_COLUMNS = {
    user_rating: { min: 0, max: 100 },
    bayesian_rating: { min: 2, max: 5 },
    site_rating: { min: 1, max: 5 }
};

function renderCellValue(val, colName = null) {
    if (typeof val !== 'string') return val;

    const text = val.trim();

    const toFileUrl = path => {
        if (path.startsWith('http')) return path;
        let urlPath = path.replace(/\\/g, '/');
        if (!urlPath.startsWith('/')) urlPath = '/' + urlPath;
        return 'file:///' + urlPath;
    };

    // Excel-style HYPERLINK formula
    const hyperlinkMatch = text.match(/^=HYPERLINK\("([^"]+)",\s*"([^"]+)"\)$/i);
    if (hyperlinkMatch) {
        const [, rawPath, label] = hyperlinkMatch;
        return `<a href="${toFileUrl(rawPath)}" target="_blank">${label}</a>`;
    }

    // Web URLs
    if (/^https?:\/\//i.test(text)) return `<a href="${text}" target="_blank">${text}</a>`;

    // Local Windows path
    if (/^[a-zA-Z]:\\/.test(text)) return `<a href="${toFileUrl(text)}" target="_blank">${text}</a>`;

    // Column-specific highlighting
    if (colName && HIGHLIGHT_COLUMNS[colName]) {
        const { min, max } = HIGHLIGHT_COLUMNS[colName];
        return highlightValue(text, min, max);
    }

    return text;
}

function highlightValue(val, min, max) {
    const num = parseFloat(val);
    if (isNaN(num)) return val;

    // Compute intensity 0 â†’ 1
    const intensity = Math.max(0, Math.min(1, (num - min) / (max - min)));

    const isLightMode = document.body.classList.contains('light-theme');

    // --- Four fixed extremes ---
    let low, high;
    if (isLightMode) {
        // Light mode: black text, red â†’ green
        low  = { h: 0,   s: 70, l: 80 };  // light red
        high = { h: 120, s: 70, l: 80 };  // light green (readable on black)
    } else {
        // Dark mode: white text, red â†’ green
        low  = { h: 0,   s: 70, l: 20 };  // dark red
        high = { h: 120, s: 70, l: 20 };  // dark green (readable on white)
    }

    // Interpolate HSL between low and high
    const hue = Math.round(low.h + (high.h - low.h) * intensity);
    const saturation = Math.round(low.s + (high.s - low.s) * intensity);
    const lightness = Math.round(low.l + (high.l - low.l) * intensity);
    const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    const textColor = isLightMode ? '#000000' : '#ffffff';
    const weightClass = intensity > 0.7 ? 'high' : intensity > 0.4 ? 'medium' : 'low';
    return `<span class="highlight-cell ${weightClass}" style="background-color:${bgColor}; color:${textColor}">${val}</span>`;
}

function normalizeFilters(filters) {
    const normalized = {};
    Object.entries(filters).forEach(([col, values]) => {
        normalized[col] = Array.isArray(values)
            ? values.map(v => String(v).trim()).filter(v => v !== '')
            : [];
    });
    return normalized;
}

function createOverlay(title) {
    const overlay = document.createElement('div');
    overlay.id = 'prefilterOverlay';
    Object.assign(overlay.style, {
        position: 'fixed',
        inset: '0',
        background: 'rgba(0,0,0,0.9)',
        color: 'white',
        zIndex: '3000',
        padding: '20px',
        overflowY: 'auto'
    });
    overlay.innerHTML = `<h2>${title}</h2>`;
    return overlay;
}

async function buildPrefilterUi(filters) {
    try {
        const normalized = normalizeFilters(filters);
        const overlay = createOverlay('Select Filters Before Loading Data');

        // Form wrapper
        const form = document.createElement('form');

        // Submit button outside the grid
        const actions = document.createElement('div');
        actions.className = 'prefilter-actions sticky-top';
        actions.appendChild(createSubmitButton('Apply Filters & Load CSV'));
        form.appendChild(actions);

        // Grid of filters
        const grid = document.createElement('div');
        grid.className = 'prefilter-form'; // only the filters are inside this grid
        for (const [col, values] of Object.entries(normalized)) {
            grid.appendChild(buildFilterSection(col, values));
        }
        form.appendChild(grid);

        overlay.appendChild(form);
        document.body.appendChild(overlay);

        return new Promise(resolve =>
            handleFormSubmit(form, resolve, overlay)
        );
    } catch (err) {
        console.warn('Prefilter UI failed, continuing without prefiltering:', err);
        return {};
    }
}


function buildFilterSection(col, values) {
    const section = document.createElement('section');
    section.className = 'filter-section';

    const title = document.createElement('h3');
    title.textContent = col;
    section.appendChild(title);

    if (!values.length || values.length > 30) {
        section.appendChild(createTextInput(col));
    } else {
        const list = document.createElement('div');
        list.className = 'filter-values';

        values.forEach(v => list.appendChild(createCheckbox(col, v)));
        section.appendChild(list);
    }

    return section;
}

function createTextInput(name) {
    const input = document.createElement('input');
    input.type = 'text';
    input.name = name;
    input.placeholder = `Filter ${name}â€¦`;
    return input;
}

function createCheckbox(name, value) {
    const label = document.createElement('label');
    label.className = 'filter-checkbox';

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.name = name;
    input.value = value;
    input.checked = true;

    label.append(input, document.createTextNode(value));
    return label;
}

function createSubmitButton(label = 'Submit') {
    const btn = document.createElement('button');
    btn.type = 'submit';
    btn.textContent = label;
    btn.className = 'btn';
    btn.style.marginTop = '10px';
    return btn;
}

function handleFormSubmit(form, resolve, overlay) {
    form.addEventListener('submit', e => {
        e.preventDefault();
        const preFilter = {};

        // Collect values from form inputs
        new FormData(form).forEach((value, key) => {
            value = String(value).trim();
            if (!value) return; // skip empty inputs

            if (!preFilter[key]) preFilter[key] = [];
            preFilter[key].push(value);
        });

        overlay.remove();
        resolve(preFilter);
    });
}

function loadAndUpdateTheme() {
    // Load saved theme
    if (localStorage.getItem('theme') === 'light') {
        document.body.classList.add('light-theme');
    }
    updateThemeButton()
}

function updateThemeButton() {
    const isLight = document.body.classList.contains('light-theme');
    themeToggleBtn.textContent = isLight ? 'ðŸŒž Light' : 'ðŸŒ™ Dark';
}


loadAndUpdateTheme();


// Reset filters button
resetFiltersBtn.addEventListener('click', () => {
    if (!$.fn.DataTable.isDataTable(tableElement)) return;

    const dt = tableElement.DataTable();

    // Reset column searches
    dt.columns().every(function() {
        this.search('');
    });

    // Reset checkboxes
    $('.filter-box input[type="checkbox"]').prop('checked', true);

    // Reset text inputs
    $('.filter-text').val('');

    // Reset column order
    if (dt.colReorder) dt.colReorder.reset();

    // Reset sorting
    dt.order([]).draw(); // only one redraw here
});

// Theme toggle button
themeToggleBtn.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    const isLight = document.body.classList.contains('light-theme');
    localStorage.setItem('theme', isLight ? 'light' : 'dark');
    updateThemeButton();
});


</script>








<!-- Code injected for standalone web deployment -->
<script>
(async () => {
    while (true) {
        try {
            const response = await fetch('data/game_data.csv');
            if (!response.ok) throw new Error('Failed to fetch CSV');

            const csvText = await response.text(); // now clonable
            if (await loadCsv(csvText)) break;
        } catch (err) {
            console.error('Loading attempt failed:', err);
            alert(err.message || 'Failed to load data');
        }
    }
})();
</script>




</body>
</html>
